> EXPLAIN命令是查看查询优化器如何决定执行查询的主要方法。

#### EXPLAIN中的列

##### 1、id列

这一列总是包含一个编号，标识SELECT所属的行。如果在语句当中没有子查询或联合，那么只会有唯一的SELECT，于是每一行在这个列中都将显示一个1。否则，内层的SELECT一般会顺序编号，对应于其在原始语句中的位置。

##### 2、select_type列

这一列显示了对应行是简单还是复杂SELECT。总共有如下几种标记：

- SIMPLE： 表示此查询不包含 UNION 查询或子查询
- PRIMARY： 表示此查询是最外层的查询
- SUBQUERY： 包含在SELECT列表中的子查询中的SLECT（换句话说，不在FROM子句中）
- UNION： 表示此查询是 UNION 的第二或随后的查询
- DEPENDENT UNION：UNION 中的第二个或后面的查询语句, 取决于外面的查询
- UNION RESULT：UNION 的结果，用来从UNION的匿名临时表检索结果的SELECT。
- DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.
- DERIVED：用来表示包含在FROM子句的子查询中的SELECT，MySQL会递归执行并将结果放到一个临时表中、服务器内部称其“派生表”，因为该临时表是从子查询中派生来的。

##### 3、table列

显示了对应行正在访问哪个表或衍生的表。

##### 4、type

访问类型-换言之就是MySQL决定如何查找表中的行。

type 常用的取值有:

- ALL: 表示**全表扫描**，这个类型的查询是性能最差的查询之一。通常来说， 我们的查询不应该出现 ALL 类型的查询，因为这样的查询在数据量大的情况下，对数据库的性能是巨大的灾难。如一个查询是 ALL 类型查询， 那么一般来说可以对相应的字段添加索引来避免。
- index: 表示全索引扫描(full index scan)，和 ALL 类型类似，只不过 ALL 类型是全表扫描，而 index 类型则仅仅扫描所有的索引， 而不扫描数据。index 类型通常出现在：所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据。当是这种情况时，Extra 字段 会显示 Using index，说明MySQL正在使用覆盖索引，它只扫描索引的数据。
- range: 表示使用索引范围查询，通过索引字段范围获取表中部分数据记录。这个类型通常出现在 =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, IN() 操作中。
- ref: 此类型通常出现在多表的 join 查询，针对于**非唯一或非主键索引**，或者是使用了 最左前缀 规则索引的查询。ref_or_null是ref之上的一个变体，它意味着MySQL必须在初次查找的结果里进行第二次查找以找出NULL条目。
- eq_ref: 此类型通常出现在多表的 join 查询，MySQL知道最多只返回一条符合条件的记录，这种访问方法可以在MySQL使用**主键或者唯一性索引**查找时看到，它会将它们与某个参考值做比较。并且查询的比较操作通常是 =，查询效率较高。

- system: 表中只有一条数据， 这个类型是特殊的 const 类型。
- const: 针对主键或唯一索引的等值查询扫描，最多只返回一行数据。const 查询速度非常快， 因为它仅仅读取一次即可。当MySQL能对查询的某部分进行优化并将其转换成一个常量时，它就会使用这种访问类型。
- NULL：这种访问方式意味着MySQL能在优化阶段分解查询语句，在执行阶段甚至用不着在访问表或者索引。例如：从一个索引列中选取最小值可以通过单独查找索引来完成，不需要在执行时访问表。

通常来说, 不同的 type 类型的性能关系如下:

**ALL < index < range ~ index_merge < ref < eq_ref < const < system<NULL**

##### 5. possible_keys

它表示 MySQL在查询时，可能使用到的索引。注意，即使有些索引在 possible_keys 中出现，但是并不表示此索引会真正地被 mysql 使用到。MySQL在查询时具体使用了哪些索引，由 key 字段决定。

##### 6、key

 MySQL在当前查询时所真正使用到的索引。

> possible_key 揭示了哪一个索引能有助于高效地行查找，而key显示的是优化采用哪一个索引可以最小化查询成本。

##### 7、key_len

表示查询优化器使用了索引的字节数，这个字段可以评估组合索引是否完全被使用。

##### 8、ref

这一列显示了之前的表在key列记录的索引中查找值所用的列或常量。

##### 9、rows

估算 sql 要查找到结果集需要扫描读取的数据行数，这个值非常直观的显示 sql 效率好坏， 原则上 rows 越少越好。这个rows 值是MySQL认为它要检查的行数，而不是结果集里的行数。

##### 10、extra

explain 中的很多额外的信息会在 extra 字段显示, 常见的有以下几种内容:

- using filesort ：意味着 MySQL会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。需额外的排序操作，不能通过索引顺序达到排序效果。一般有 using filesort都建议优化去掉，因为这样的查询 cpu 资源消耗大。
- using index：**覆盖索引**扫描，表示查询在索引树中就可查找所需数据，不用扫描表数据文件，往往说明性能不错。
- using temporary：查询有使用临时表, 一般出现于排序， 分组和多表 join 的情况， 查询效率不高，建议优化。
- using where ：这意味着MySQL服务器将在存储引擎检索行后再进行过滤。许多WHERE条件里涉及索引中的列， 当（并且如果）它读取索引时，就能被存储引擎校验，因此不是所有带WHERE子句的查询都回显示”Using where'。有时“Using where”的出现就是一个暗示：查询可受益于不同的索引。

