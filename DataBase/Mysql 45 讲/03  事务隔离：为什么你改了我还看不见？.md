## 03 | 事务隔离：为什么你改了我还看不见？



### 隔离性与隔离级别

当数据库上有多个事务同时执行的时候，就可能出现**脏读（dirty read）**、不可重复读（non-repeatable read）、**幻读（phantom read）**的问题，为了解决这些问题，就有了“隔离级别”的概念。



SQL 标准的事务隔离级别包括：

- 读未提交（read uncommitted）：一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交（read committed）：一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读（repeatable read）：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。
- 串行化（serializable ）：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。



在实现上，隔离级别的实现是依靠视图来实现的：

- 读未提交隔离级别下直接返回记录上的最新值，没有视图概念；

- 读提交隔离级别下，在每个 SQL 语句开始执行的时候创建一致性视图。
- 可重复读隔离级别下，在事务启动时创建一致性视图，整个事务存在期间都用这个视图。（**一致性视图是在第一个 Select 语句时建立的**）
- 串行化隔离级别下直接用加锁的方式来避免并行访问。



> 查看隔离级别
>
> show variables like 'transaction_isolation' 



### 事务隔离的实现

以 “可重复读” 为说明。



在 MySQL 中，每条记录在更新的时候都会同时记录一条回滚操作（undo log）。记录上的最新值，都可以通过回滚，得到前一个状态的值。



<img src="https://cdn.jsdelivr.net/gh/YangZhiqiang98/ImageBed/20230625202618.png" alt="img" style="zoom:50%;" />



这样，同一条记录咋系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。



**MVCC: 多版本并发控制，通过 undo log 版本链和 read-view 实现事务隔离。**



undo log 回滚日志删除时机？

在不需要时删除。即系统中，没有事务需要用到这些回滚日志时，回滚日志会被删除。



尽量不要使用长事务？

长事务会导致数据库保留很老的事务视图，这些事务相关的回滚记录都无法删除，会导致占用大量的存储空间。同时，长事务还占用所资源。







