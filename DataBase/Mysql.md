### MySQL概述

#### MySQL逻辑架构

![[MySQL服务器逻辑架构图]](image/Mysql/20201227190333.png)

[MySQL逻辑架构图](https://www.processon.com/view/link/5fe86a0f1e08531ceab69e86)

- 大多数MySQL核心功能都在第二层架构，包括查询解析、分析、优化、缓存以及所有的内置函数，所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。

- 第三层包含了存储引擎。存储引擎负责MySQL中数据的存储与提取。但存储引擎不会去解析SQL（InnoDB是个例外，它会解析外键定义）。

#### 事务

- 原子性（atomicity）：一个事务必须被视为一个不可分割的最小工作单元。
- 一致性（consistency）：数据库总是从一个一致性状态转换到另外一个一致性的状态。
- 隔离性（isolation）：通常来说，一个事务所做的修改在最终提交之前，对其他事务是不可见的。
- 持久性（durability）：一旦事务提交，则其所做的修改就会永久保存到数据库中。

#### 隔离级别

##### 四种隔离级别

- Read Uncommitted(未提交读)

  在Read Uncommitted级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据。这也被称为**脏读**（Dirty Read）。

- Read Commited(提交读)

  大多数数据库系统默认隔离级别都是Read Commited（但**MySQL不是**）。在这个级别，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。但会出现**不可重复读**（norepeatable read）。因为两次执行同样的查询，可能会得到不一样的结果、如：事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条**数据改变**了，然后事务A再次读取的时候，发现数据不匹配了，就是所谓的不可重复读了。

- Repeatable Read(可重复读)

  该级别保证了在同一事务中多次读取同样记录的结果是一致的。但会出现**幻读**（Phantom Read）的问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了**新的记录**，当之前的事务再次读取该范围的记录时，会产生幻行（Phantom Row）。Innodb和XtraDB存储引擎通过多版本并发控制（**MVCC**，Multiversion Concurrency Control）解决了幻读的问题。

- Serializable(可串行化)

  最高的隔离级别。它通过强制事务串行执行。Serializable会在读取的每一行数据上都加锁。

| 隔离级别                  | 脏读 | 不可重复读 | 幻读 | 加锁读 |
| ------------------------- | ---- | ---------- | ---- | ------ |
| Read Uncommitted          | Yes  | Yes        | Yes  | No     |
| Read Commited             | No   | Yes        | Yes  | No     |
| Repeatable Read           | No   | No         | Yes  | No     |
| Serializable              | No   | No         | No   | Yes    |
| #### MVCC(多版本并发控制) |      |            |      |        |

MVCC的实现是通过保存数据在某个时间点的快照来实现的。也就说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。

Innodb的MVCC是通过在每行记录后面保存两个隐藏列来实现的，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际时间值，而是系统版本号。每开始一个事务，系统版本号就会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

在Repeatable Read隔离级别下，MVCC具体操作：

**SELECT**：

	Innodb会根据以下两个条件检查每行记录：
	
		a. Innodb只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号）。这样可以确保事务读取的行，要么是在事务开始之前已经存在的，要么是事务自身插入或者修改过的。
	
		b. 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。

只有符合上述两个条件的记录，才能返回作为查询结果。

**INSERT**：

	Innodb为新插入的每一行保存当前系统版本号作为行版本号。

**DELETE**:

	Innodb为删除的每一行保存当前系统版本号作为行删除标识。

**UPDATE**：

	Innodb为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。

保存这两个额外系统版本号，使大数读操作都可以不用加锁。**MVCC只在Repeatable Read和Read Commited两个隔离级别下工作**。因为Read Uncommitted总是读取最新的数据行，而不是符合当前事务版本的数据行。而Serializable则会对所有读取的行都加锁。

#### InnoDB和MyISAM存储引擎

##### InnoDB存储引擎

- InnoDB的数据存储在表空间（tablespace)。表空间是由InnoDB管理的一个黑匣子，由一系列的数据文件组成。
- InnoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别，其默认级别是REPEATABLE READ（可重复读），并通过间隙锁（next-key locking）策略防止幻读的出现。间隙锁使得InnoDB不仅仅锁定查询所涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。
- InnoDB表示基于聚簇索引建立的。
- InnoDB内部做了很多优化，包括从磁盘读取数据时采用的可预测性读，能够自动在内存中创建hash索引以加速读操作的自适应哈希索引（adaptive hash index）,以及能够加速插入操作的插入缓冲区（insert buffer）等。
- 事务型的存储引擎。

##### MyISAM存储引擎

- 不支持事务和行级锁，崩溃后无法安全恢复。
- 将表存储在两个文件中：数据文件（.MYD）和索引文件（.MYI）。MyISAM数据以紧密格式存储。
- MyISAM对整张表加锁，而不是针对行。读取时加共享锁，写入时则对表加排他锁。但是在表有读取查询的同时，也可以往表中插入新的记录。（并发插入 CONCURRENT INSERT）
- 支持全文索引。
- 延迟更新索引键（Delayed Key Write）。创建MyISAM 表的时候，如果指定了DELAY_KEY_WRITE选项，在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区（in-memory key buffer），只要在清理键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘。这种方式可以极大地提升写入性能，但是在数据或者主机崩溃时造成索引损坏。
- MyISAM压缩表。如果表在创建并导入数据后，不会再进行修改操作，那么这样的表或许适合采用MyISAM压缩表。