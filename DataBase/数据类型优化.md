### MYSQL数据类型与存储空间

（重新搞）

##### 整型

| 类型      | 存储空间(字节) | 最小值（有符号） | 最小值（无符号） | 最大值（有符号） | 最大值（无符号） |
| --------- | -------------- | ---------------- | ---------------- | ---------------- | ---------------- |
| TINYINT   | 1              | -128             | 0                | 127              | 255              |
| SMALLINT  | 2              | -32768           | 0                | 32767            | 65535            |
| MEDIUMINT | 3              | -8388608         | 0                | 8388607          | 16777215         |
| INT       | 4              | -2147483648      | 0                | 2147483647       | 4294967295       |
| BIGINT    | 8              | $-2^{63}$ | 0                |  $2^{63}-1$  | $ 2^{64}-1 $ |

##### 时间类型

| 时间日期类型 | 存储空间（字节） | 日期格式            | 最小值              | 最大值              |
| ------------ | ---------------- | ------------------- | ------------------- | ------------------- |
| DATETIME     | 8                | YYYY-MM-DD HH:MM:SS | 1000-01-01 00:00:00 | 9999-12-31 23:59:59 |
| TIMESTAMP    | 4                | YYYY-MM-DD HH:MM:SS | 19700101080001      | 2038年的某个时刻    |
| DATE         | 4                | YYYY-MM-DD          | 1000-01-01          | 9999-12-31          |
| TIME         | 3                | HH:MM:SS            | -838:59:59          | 838:59:59           |
| YEAR         | 1                | YYYY                | 1901                | 2155                |

##### 数字类型

| 时间日期类型                                                 | 存储空间（字节） |
| ------------------------------------------------------------ | ---------------- |
| FLOAT                                                        | 4                |
| DOUBLE                                                       | 8                |
| DECIMAL                                                      |                  |
| [`TINYINT`](https://dev.mysql.com/doc/refman/8.0/en/integer-types.html) | 1                |
| [`SMALLINT`](https://dev.mysql.com/doc/refman/8.0/en/integer-types.html) | 2                |
| [`MEDIUMINT`](https://dev.mysql.com/doc/refman/8.0/en/integer-types.html) | 3                |
| [`INT`](https://dev.mysql.com/doc/refman/8.0/en/integer-types.html), [`INTEGER`](https://dev.mysql.com/doc/refman/8.0/en/integer-types.html) | 4                |
| [`BIGINT`](https://dev.mysql.com/doc/refman/8.0/en/integer-types.html) | 8                |



### MySQL数据类型选择原则

##### 更小的通常更好

​		更小的数据类型通常更快，因为它们占用更少的磁盘、内存和 CPU 缓存，并且处理时需要的 CPU 周期也更少。

##### 简单就好

​		简单数据类型的操作通常需要更少的 CPU 周期。如，整型比字符操作代价更低，应该使用 MySQL 内建的类型而不是字符串来存储日期和时间，应用整型存储IP地址。

##### 尽量避免NULL

​		通常情况下最好指定列为 NOT  NULL，除非真的需要存储 NULL 值。

#### 整型类型

​		如果存储整数，可以使用 TINYINT，SMALLINT，MEDIUMINT，INT， BIGINT，分别使用8、16、24、32、64位存储空间，他们可以存储的范围从 $-2^{N-1} $ 到 $2^{N-1}-1$,其中 N 是存储空间的位数。

​		整型类型又有可选的 UNSINGNED 属性，表示不允许负值，这大致可以使得整数的上限提高一倍。

​		MySQL 可以为整数类型指定宽度：该宽度大多没有意义，它不会限制值的合法范围，只是规定了 MySQL 的一些交互工具用来显示字符的个数。对于存储和计算来说，INT(1) 和 INT(20) 是一样的。

#### 实数类型

实数是带有小数部分的数字。

​		DECIMAL 类型用于存储精确的小数，支持精确计算。因为 CPU 支持对 DECIMAL 的直接计算，所以 MySQL 服务器自身实现了 DECMIAL 的高精度计算。相对而言，CPU 直接支持原生浮点计算，所以浮点运算明显更快。

​		浮点和 DECIMAL 都可以指定精度。对于 DECIMAL 列，可以指定小数点前后所允许的最大位数。这会影响列的空间消耗。MySQL 将数字打包保存到一个二进制字符串中（每 4 个 字节存 9 个数字）。例如，DECIMAL（18,9）小数点两边将各存储 9 个数字，一共使用 9 个字节：小数点前的数字用 4 个字节，小数点后的数字用 4 个字节，小数点本身占 1 个字节。

​		DECIMAL类型允许最多 64 个数字，DECIMAL 只是一种存储格式，在计算中 DECIMAL 会转换成 DOUBLE 类型。

​		浮点类型在存储同样范围的值时，通常比 DECIMAL 使用更少的空间。MySQL 使用 DOUBLE 作为内部浮点计算的类型。

​		因为需要额外的空间和计算开销，所以应该尽量只在对小数进行精确计算时才是用 DECIMAL。但在数据量表较大时，可以考虑使用 BIGINT 代替 DECIMAL，只要乘以相应的倍数即可，这样可以同时避免浮点存储计算不精确和DECIMAL 精确计算代价高的问题。

#### 字符串类型

##### VARCHAR

​		VARCHAR 类型用于==存储可变长字符串，系统会根据实际存储的数据来分配合适的空间大小==（数据没有超过数据定义大小）。因为 VAECHAR 要记录数据长度，所以 VARCHAR 需要使用 1 或 2 个额外字节记录字符串的长度：如果列的最大长度小于或等于 255 个字节，则只使用 1 个字节表示，否则使用 2 个字节。

​		由于行是变长的，在 UPDATE 时可能使行变得比原来更长，如果一个行占用的空间增长，并且在页内没有更多的空间存储，则需要做额外的工作。（InnoDB 需要分裂页来使行可以放进页内）

##### CHAR

​		CHAR 用于存储定长字符，指定长度后，系统一定会分配指定的空间用于存储数据。当存储 CHAR值时，MYSQL 会删除所有的==末尾空格==。

​		CHAR 适合存储很短的字符串，或者所有值都接近同一个长度。对于经常变更的数据，CHAR 也比 VARCHAR 好，因为定长的 CHAR 类型不容易产生碎片。对于非常短的列，CHAR 比 VARCHAR 在存储空间上也更有效率。

##### BLOB 和 TEXT 类型

​		BLOB 和 TEXT 是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。BLOB 没有排序规则或字符集，而 TEXT 类型有排序规则和字符集。

​		MYSQL 对于BLOB 和 TEXT 排序：只对每个列的最前 `max_sort_length` 字节而不是 整个字符串做排序。如果只需要排序前面的一小部分字符，则可减小 `max_sort_length` 的配置，或者使用 `order by substring(column,length)`。

##### ENUM 枚举

​		MYSQL 在存储枚举时非常紧凑，会根据列表值的数量压缩到一个或者两个字节中。MYSQL 在内部会将每个值在列表中的位置保存为整数，并且在表的 .frm 文件中保存 “ 数字-字符串 “ 映射关系的 ”  查找表 “ 。不建议使用数字作为 ENUM 枚举常量，这种双重性容易导致混乱。



#### 日期和时间类型

​		MYSQL 能存储的最小时间粒度为秒。提供了两种相似的日期类型：DATETIME 和 TIMESTAMP。

| 时间日期类型 | 存储空间（字节） | 日期格式            | 最小值              | 最大值              | 特点       |
| ------------ | ---------------- | ------------------- | ------------------- | ------------------- | ---------- |
| DATETIME     | 8                | YYYY-MM-DD HH:MM:SS | 1000-01-01 00:00:00 | 9999-12-31 23:59:59 | 与时区无关 |
| TIMESTAMP    | 4                | YYYY-MM-DD HH:MM:SS | 19700101080001      | 2038年的某个时刻    | 与时区有关 |

​		除了特殊行为之外，通常应该尽量使用 TIMESTAMP，因为空间效率更高。

​		如何存储比秒更小粒度的时间值？可以使用 BIGINT 类型存储微秒级别的时间截，或者使用 DOUBLE 存储秒之后的小数部分。

#### 位数据类型

​		MYSQL 有少数几种存储类型使用紧凑的位存储数据。所有这些位类型，不管底层存储格式和处理方式如何，从技术上来说都是字符串类型。

##### BIT

​		**MYSQL 把 BIT 当做字符串类型，而不是数字类型**。在检索 BIT(1) 的值是，结果是一个包含二进制 0 或 1 值的字符串，而不是 ASCII码的 ”0“ 或 ”1“。然而，在数字上下文的场景中检索时，结果将是位字符串转换成的数字。

```sql
create table bittest(a bit(8));
insert into bittest values (b'00111001');
select a, a + 0 from bittest;
```

+--------------+-------+
|a       		 |a + 0 |
+--------------+--------+
|00111001|57     |
+--------------+--------+

如果想在一个 bit 的存储空间中存储一个 true/false 值，另一个方法就是创建一个为空的 CHAR(0) 列。该列可以保存空值（NULL）或者长度为零的字符串（空字符串）。

##### SET

​		在 MYSQL 内部是一系列打包的位的集合来表示的。但是改变列的定义的代价较高，需要 ALTER TABLE。一般来说，也无法在 SET 列上通过索引来查找。

#### 选择标识符（identifier）

​		如果可能， 应该避免使用字符串类型作为标识列，因为他们很消耗空间，而且通常比数字类型慢。

​		如果存储 UUID 值，则应该移除 “-” 符号；或者更好的做法是，用 UNHEX()  函数转换 UUID 值为 16 字节的数字，并且存储在一个 BINARY(16)  列中。检索时可以通过 HEX() 函数来格式化为十六进制格式。

##### 加快ALTER TABLE 操作的速度

​		**不是所有的 ALTER TABLE 操作都会引起表重建**。

```SQL
alter table table1 modify column string varchar(20) not null default '1';
alter table table1 alter column  string set default '1';
```

​		第一种方法会拷贝张表到一张新表。第二种方法会直接修改  .frm 文件而不涉及表数据。



#### 总结

- 尽量避免过度设计，例如有很多列的表设计
- 使用小而简单的合适数据类型，除非真实数据模型中有确切的需要，否则应该尽可能避免使用 NULL 值
- 尽量使用相同的数据类型存储相似或相关的值，尤其是要在关联条件中使用的列
- 注意可变长字符串，其在临时表和排序时可能导致悲观的按最大长度分配内存
- 尽量使用整型定义标识列
- 避免使用 MYSQL 已经遗弃的特性，例如指定浮点数的精度，或者整数的显示宽度
- 小心使用 ENUM 和 SET。虽然他们使用起来很方便，但是不要滥用，否则有时候会变成陷阱。最好避免使用 BIT

