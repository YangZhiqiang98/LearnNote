[TOC]
### Java代码执行流程
<img src="http://image.yzqfrist.com/20201126232011.png" alt="Java代码执行流程" style="zoom:80%;" />

### 内存结构概述
<img src="http://image.yzqfrist.com/20201127065223.png" alt="JVM架构" style="zoom:80%;" />

### 类加载子系统
<img src="http://image.yzqfrist.com/20201126231611.png" alt="类加载子系统" style="zoom: 67%;" />

- 类加载器子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件标识。（0xCAFEBABE）(咖啡宝贝)
- ClassLoader只负责class文件的加载，至于它是否可以运行，则由 Execution Engine决定。
- 加载的类信息存放在一块称为**方法区**的内存空间，除了类的信息外，方法区中还会存放**运行时常量池信息**，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）。
#### 类的加载过程
<img src="http://image.yzqfrist.com/20201126232153.png" alt="类加载过程" style="zoom:50%;" />

##### 加载

1、通过一个类的全限定名获取定义此类的二进制字节流
2、将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构
3、**在内存中生成一个代表这个类的java.lang.Class对象**，作为方法区这个类的各种数据的访问入口。

##### 链接
###### 验证（Verify）
- 目的在于确保Class文件的字节流中信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。
- 主要包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证
 ###### 准备（Prepare）
 - **为类变量（静态变量）分配内存并设置该类变量的初始值，即零值。**
 - 这里**不包含用final修饰的 static，因为final在编译的时候就会分配了，准备阶段会显式初始化**（final static 在这个阶段显式初始化）
 - 这里**不会为实例变量分配初始化**，类变量会分配在方法区中，而实例变量是会随对象一起分配到Java堆中。
 ###### 解析（Resolve）
 - 将常量池内的符号引用转换为直接引用的过程。
 - 事实上，解析操作往往会伴随着JVM在执行完初始化之后再操作。
 - 解析动作主要针对类、接口、字段、类方法、接口方法、方法类型等。对应常量池中的Constant_class_info、constant_fieldref_info、constant_methodref_info等。



 ##### 初始化
 - **初始化阶段就是执行类构造器方法``<clinit>()``的过程**。（不是类中的构造器）
 - 此方法不需定义，是javac编译器自动收集类中所有**类变量的赋值动作和静态代码块中的语句**合并而来。
 - 构造器方法中指令按语句在源文件中出现的顺序执行。静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。
 - **`<clinit>（）`不同于类的构造器，**（关联：构造器是虚拟机视角下的`<init>()`），不需要显式地调用父类构造器。
 -  JVM会保证在子类的`<clinit>()`执行前，父类的`<clinit>()`已经执行完毕。因此在Java虚拟机中第一个被执行的`<clinit>()`方法的类型肯定是java.lang.Object。
 -  `<clinit>（）`方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成`<clinit>()`方法。
 -  接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成`<clinit>()`方法。但接口与类不同的是，执行接口的`<clinit>()`方法不需要先执行父接口的`<clinit>()`方法，因为只有当父类接口中定义的变量被使用时，父类接口才会被初始化。此外，接口的实现类在初始时也一样不会执行接口的`<clinit>()` 方法。[Java接口](https://www.runoob.com/java/java-interfaces.html)
 -  虚拟机必须保证一个类的`<clinit>()`方法在多线程下被同步加锁

```java
public class ClassInitTest {

  private static int num = 1;

  static {
    num = 2;
    number = 20;
    System.out.println(number);//非法的前向引用
  }

  private static int number = 10; //linking之prepare: number = 0 --> inital : 20 --> 10

  public static void main(String[] args) {
    System.out.println(ClassInitTest.num);// 1
    System.out.println(ClassInitTest.number); // 10
  }
}

```
 从字节码文件可以看到：在链接阶段，会为类变量分配内存并设置该类变量的初始值，即零值。所以在static代码块中给number赋值并不会报错，但是初始化阶段按照出现顺序初始化，所以最后number = 10；但是在静态代码块中打印number会报错，报非法前向引用。 
![Image](http://image.yzqfrist.com/20210111200933.png)

 #### 类加载器的分类
 JVM支持两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader）也称为引导类加载器，这个类加载器实用C/C++实现，是虚拟机自身的一部分，Java的核心类库都是使用引导类加载器进行加载的；一种是自定义类加载器（User-Defined ClassLoader），这些类加载器都由Java语言实现，独立存在与虚拟机外部，这些类加载器全都继承自抽象类java.lang.ClassLoader。

<img src="http://image.yzqfrist.com/20210111200923.png" alt="类加载器" style="zoom:50%;" />

 ##### 启动类加载器（引导类加载器，Bootstrap ClassLoader）

* 这个类加载器使用C/C++语言实现，嵌套在JVM内部
* 它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar、resource.jar或sum.boot.path路径下的内容），用于提供 JVM自身需要的类
* 加载扩展类和应用程序类加载器，并指定为他们的父类加载器
* 出于安全考虑，Boostrap启动类加载器只加载包名为java,javax,sun等开头的类

##### 扩展类加载器（Extension ClassLoader）

* Java语言编写，由`sun.misc.Launcher$ExtClassLoader`实现
* 派生于ClassLoader类
* 父类加载器为启动类加载器
* 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载

##### 应用类程序加载器（系统类加载器，AppCLassLoader）
*  Java语言编写，由`sun.misc.Launcher$ExtClassLoader`实现
* 派生于`ClassLoader`类
* 父类加载器为扩展类加载器
* 它负责加载环境变量classpath或系统属性 java.class.path指定路径下的类库
* 该类加载器是程序中默认的类加载器，一般来说，Java应用的类都是由它来加载完成
* 通过`ClassLoader#getSystemClassLoader()`方法可以获取到该类加载器


> JDK1.8 环境下
```java
public class ClassLoaderTest {

  public static void main(String[] args) {
    System.out.println("********启动类加载器******");
    //获取BootstrapClassLoader能够加载的api的路径
    URL[] urLs = Launcher.getBootstrapClassPath().getURLs();
    for (URL url : urLs) {
      System.out.println(url.toExternalForm());
    }

    //获取Extension ClassLoader能够加载的api的路径
    System.out.println("************扩展类加载器*************");
    String extDirs = System.getProperty("java.ext.dirs");
    for(String path: extDirs.split(";")){
      System.out.println(path);
    }
  }
}

```

```
********启动类加载器******
file:/C:/Program%20Files/Java/jdk1.8.0_111/jre/lib/resources.jar
file:/C:/Program%20Files/Java/jdk1.8.0_111/jre/lib/rt.jar
file:/C:/Program%20Files/Java/jdk1.8.0_111/jre/lib/sunrsasign.jar
file:/C:/Program%20Files/Java/jdk1.8.0_111/jre/lib/jsse.jar
file:/C:/Program%20Files/Java/jdk1.8.0_111/jre/lib/jce.jar
file:/C:/Program%20Files/Java/jdk1.8.0_111/jre/lib/charsets.jar
file:/C:/Program%20Files/Java/jdk1.8.0_111/jre/lib/jfr.jar
file:/C:/Program%20Files/Java/jdk1.8.0_111/jre/classes
************扩展类加载器*************
C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext
C:\WINDOWS\Sun\Java\lib\ext
```

##### 用户自定义类加载器
###### 为什么要自定义类加载器
* 隔离加载类
* 修改类加载的方式
* 扩展加载源
* 防止源码泄露

###### 用户自定义类加载器的实现步骤
1. 继承抽象类`java.lang.ClassLoader`类
2. 把自定义的类加载逻辑写在`findclass()`方法中
3. 如果需求不复杂，可以直接继承`URLClassLoader`类，可以避免自己去编写`findClass()`方法以及获取字节码流的方式，使得自定义类加载器编写更加简洁

> ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自它（不包括启动类加载器）

| 方法名称                                             | 描述                                                         |
| ---------------------------------------------------- | ------------------------------------------------------------ |
| getParent()                                          | 返回该类加载器的超类加载器                                   |
| loadClass(String name)                               | 加载名称为name的类，返回结果为java.lang.Class类的实例        |
| findClass(String name)                               | 查找名称为name的类，返回结果为java.lang.Class类的实例        |
| findLoadedClass(String name)                         | 查找名称为name的已经被加载的类，返回结果为java.lang.Class类的实例 |
| defineClass(String name, byte[] b, int off, int len) | 把字节数组b中的内容转换为一个Java类，返回结果为java.lang.Class类的实例 |
| resolveClass(Class<?> c)                             | 连接指定的一个Java类                                         |

<img src="http://image.yzqfrist.com/20201129094149.png" alt="关于ClassLoader" style="zoom:50%;" />

##### 获取ClassLoader的途径

1、**获取当前类的ClassLoader：clazz.getClassLoader()**
2、**获取当前线程上下文的ClassLoader： Thread.currentThread().getContextClassLoader()**
3、**获取系统的ClassLoader：ClassLoader.getSystemClassLoader()**
4、**获取调用者的ClassLoader：DriverManager.getCallerClassLoader()**


### 双亲委派机制
 Java虚拟机对class文件采用的是**按需加载**的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且在加载某个类的class文件时，Java虚拟机采用的是**双亲委派机制**，即把请求交由父类处理，它是一种任务委派模式。

 <img src="http://image.yzqfrist.com/20201129164523.png" alt="双亲委派机制" style="zoom:50%;" />

##### 工作原理

1). 如果一个类加载器收到了类加载请求它不会自己先去加载，而是把这个请求委托给父类的加载器去执行。
2). 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器。
3). 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。

##### 优势
避免重复加载 和 避免核心类被篡改
##### 双亲委派模型破坏举例（4次）
原生的JDBC中Driver驱动本身只是一个接口，并没有具体的实现，具体的实现是由不同数据库类型去实现的。例如，MySQL的mysql-connector-.jar中的Driver类具体实现的。 原生的JDBC中的类是放在rt.jar包的，是由启动类加载器进行类加载的，在JDBC中的Driver类中需要动态去加载不同数据库类型的Driver类，而mysql-connector-.jar中的Driver类是用户自己写的代码，那启动类加载器肯定是不能进行加载的，既然是自己编写的代码，那就需要由应用程序启动类去进行类加载。于是乎，这个时候就引入**线程上下文件类加载器(Thread Context ClassLoader)** 。有了这个东西之后，程序就可以把原本需要由启动类加载器进行加载的类，由应用程序类加载器去进行加载了。

![双亲委派举例](http://image.yzqfrist.com/20201129192127.png)

##### 模块化下的类加载器（JDK9）
1) 扩展类加载器（Extension Class Loader）被平台类加载器（Platform Class  Loader）取代。
2) 平台类加载器和应用类加载器都不再派生自`java.net.URLClassLoader`。启动类加载器、平台类加载器、应用程序类加载器全部继承于`jdk.internal.loader.BuiltinClasLoader`,在`BuiltinClasLoader`中实现了新的模块化架构下类如何从模块中加载的逻辑，以及模块中资源可访问性的处理。

JDK9之前的类加载器继承架构

![JDK9之前的类加载器继承架构](http://image.yzqfrist.com/20201208070753.png)

JDK9以及之后的类加载器继承架构

![JDK9及以后的类加载器继承架构](http://image.yzqfrist.com/20201208071126.png)

从上图可发现"BootClassLoader”存在，启动类加载器现在是Java虚拟机内部和Java类库共同协作实现的类加载器，尽管有了BootClassLoader这样的Java类，但为了与之前的代码保持兼容，所有在获取启动类加载器的场景中仍然返回null来代替，而不会得到BootClassLoader的实例。

**类加载委派关系：当平台和应用类加载器收到类加载请求，在委派给父类加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载，（也许可以算是对双亲委派的第四次破坏）。**

<img src="http://image.yzqfrist.com/20201208072422.png" alt="JDK9 后的类加载器委派关系" style="zoom:50%;" />

### 其他
在JVM中表示两个class对象是否为同一个类存在两个必要条件：
* 类的全限定类名必须一致，包括包名。
* 加载这个类的ClassLoader（指ClassLoader实例对象）必须相同

换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。 

JVM必须知道一个类型是由启动加载器加载还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会**将这个类加载的一个引用作为类型信息的一部分保存在方法区中**。JVM在动态链接的时候需要这个信息，当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。这对JVM区分名字空间的方式是至关重要的。

Java程序对类的使用方式分为：**主动使用和被动使用**
* 主动使用，又分为七种情况：
    1. 创建类的实例
    2. 访问某个类或接口的静态变量，或者对该静态变量赋值
    3. 调用类的静态方法
    4. 反射
    5. 初始化一个类的子类
    6. Java虚拟机启动时被标识为启动类的类
    7. JDK7 开始提供的动态语言支持：`java.lang.invoke.MehtodHandle`实例的解析结果REF_getStatic、 REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化

除以上七种情况，其他使用Java类的方式都被看作是对**类的被动使用**，都**不会导致类的初始化**。

### 运行时数据区概述及线程

![内存布局](http://image.yzqfrist.com/20201129214548.jpg)
* 每个线程：独占程序计数器、虚拟机栈和本地方法栈
* 线程间共享：堆、堆外内存（永久代或元空间、代码缓存）

每个JVM 只有一个Runtime实例，相当于内存结构中的中间部分（运行时数据）。
![Runtime](http://image.yzqfrist.com/20201129222140.png)

JVM后台系统线程：

* **虚拟机线程**：这种线程的操作是需要JVM在达到安全点(SafePoint)才会出现，这些操作必须在不同的线程中发生的原因是它们都需要达到安全点，这样堆才不会变化。这种线程的执行类型包括“stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。
* **周期任务线程**：这种线程是时间周期事件的体现（如中断），它们一般用于周期性操作的调度执行
* **GC线程**：这种线程对在JVM里不同种类的垃圾收集行为提供了支持
* **编译线程**：这种线程在运行时会将字节码编译成本地代码
* **信号调度线程**：这种线程在接收信号并发送给JVM， 在它内部通过调用适当的方法进行处理。

#### 程序计数器（私有）
程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的**行号指示器**。用来存储指向下一条指令的地址，也就是即将要执行的指令代码。由执行引擎来读取下一条指令。
任何时间一个线程都只有一个方法在执行 ，也就是所谓的当前方法。如果线程在执行java方法，程序计数器会存储于当前线程正在执行的虚拟机字节码指令的地址；如果是在执行native方法，这个计数器的值应为（undefined）。

**唯一一个在Java虚拟机规范中没有规定OutOfMemoryError情况的区域**。

CPU在运行时，会不停的进行线程的切换，这样必然导致中断或恢复，为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是每一个线程分配一个PC寄存器，这样一来各个线程便可以独立计算，从而不会出现相互干扰的情况。

#### 虚拟机栈(私有)

虚拟机栈描述的是Java方法执行的线程的内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储**局部变量表、操作数栈、动态链接、方法出口**等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

##### 虚拟机栈概述
由于跨平台的设计，Java指令是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。

**优点是跨平台，指令集小，编译器容易实现；缺点是性能下降，实现同样的功能需要更多的指令。**

> **栈是运行时的单位，而堆是存储的单位。**
> 即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题,即数据怎么放，放在哪儿。

栈的优点：
1、栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器
2、java直接对java栈的操作只有入栈和出栈
3、对于栈来说不存在垃圾回收问题


###### 作用：
主管java程序的运行，它保存方法的局部变量（8中基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。


###### **栈中可能出现的异常**
java虚拟机规范中**允许java栈的大小是动态的或者是固定不变的**。
- 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机会抛出一个`StackOverflowError`异常。
- 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程的时候没有足够的内存去创建对应的虚拟机栈，那么java虚拟机栈将会抛出一个`OutOfMemoryError`异常。

> -Xss 设置每个线程可使用的内存大小，即栈的大小。
> 在相同物理内存下，减小这个值能生成更多的线程，当然操作系统对一个进程内的线程数还是有限制的，不能无限生成。线程栈的大小是个双刃剑，如果设置过小，可能会出现栈溢出，特别是在该线程内有递归、大的循环时出现溢出的可能性更大，如果该值设置过大，就有影响到创建栈的数量，如果是多线程的应用，就会出现内存溢出的错误。

##### 栈的存储单位
###### 栈中存储什么？
* 每个线程都要自己的栈，栈中的数据都是以**栈帧（Stack Frame）**的格式存在。
* 在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。
* 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。
* 每个栈帧中存储着：
    *  局部变量表（Local Variables）
    *  操作数栈（Operand Statck） (或表达式栈)
    *  动态链接（Dynamic Linking）(或指向运行时常量池的方法引用)
    *  方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）
    *  一些附加信息
    ![栈中数据](http://image.yzqfrist.com/20201130202815.png)
###### 栈运行原理
- 不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。
- 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。
- Java方法有两种返回函数的方式：**一种是正常的函数返回，使用return指令；另一种是抛出异常。不管哪种方式，都回导致栈帧被弹出**。

##### 局部变量表

局部变量表存放了编译期可知的各种java虚拟机基本数据类型（Boolean、byte、char、short、int、float、long、double）、对象引用类型（reference类型）和returnAddress类型（指向了一条字节码指令的地址）

[局部变量和成员变量区别](https://www.cnblogs.com/cainiao-chuanqi/p/11073993.html)
* 局部变量表也被称为局部变量数组或本地变量表
* **定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量**，这些数据类型各类基本数据类型、对象引用（reference），以及returnAddress类型。
* 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此**不存在数据安全问题**。
* **局部变量表所需的容量大小是在编译器期确定下来的**。并保存在方法的Code属性的maximum local variables 数据项下，在方法运行期间是不会改变局部变量表的大小的
* **方法嵌套调用的次数由栈的大小决定**。一般来说，**栈越大，方法嵌套调用次数越多**。对于一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用的次数就会减少。
* **局部变量表中的变量只在当前方法调用中有效**。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数列表的传递过程。**当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁**。
###### 关于slot的理解
* 参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。
* 局部变量表，最基本的存储单元是Slot(变量槽)
* 局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference）,returnAddress类型的变量
* 在局部变量表中，**32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot**。
    * byte、short、char在存储前被转换为int，boolean也被转换为int， 0表示false， 非0 表示true
    * long 和 double则占据两个slot

* JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值
* 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会**按照顺序被复制**到局部变量表的每一个Slot上
* **如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可**。
* 如果当前帧是由构造方法或者实例方法创建的，那么**该对象引用 this将会存放在index为0的slot处**，其余参数按照参数表顺序继续排列。
![slot](http://image.yzqfrist.com/20201201063045.png)


###### slot的重复利用
栈帧中的局部变量表中槽位是可以重用的。如果一个局部变量过了其作用域，那么在其之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。

###### 变量的分类

按照数据类型分：① 基本数据类型   ② 引用数据类型
按照在类中声明的位置分：
			① 成员变量：在使用前，都经历过默认初始化赋值
    &nbsp;  		 类变量：linking的prepare阶段：给类变量默认赋值 ---->inital阶段，给类变量显式赋值即静态代码块赋值
      	  	实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值			
			② 局部变量：在使用前，必须进行显式赋值！否则，编译不通过

**局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接引用或间接引用的对象都不会被回收**。

##### 操作数栈（Operand Stack）
- **操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈和出栈。**
- 操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。
- 操作数栈是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。
- 每一个操作数栈都回拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值。
- 栈中的任何一个元素都是可以任意的Java数据类型
    - 32bit的类型占据一个栈单位深度
    - 64bit的类型占据两个栈单位深度
- 操作数栈并非采用访问索引的方式来进行数据访问的，只能通过标准的入栈和出栈操作来完成一次数据访问。
- **如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中**，并更新PC寄存器的值。
- 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类校验阶段的数据流分析阶段要再次验证。
- 另外，我们说Java虚拟机的**解释引擎是基于栈的执行引擎**， 其中栈就是指的操作数栈。

###### 栈顶缓存技术（Top-of-Stack Cashing）技术
基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作时，也需要更多的入栈和出栈指令，这也意味着需要更多的指令分派（instruction dispatch）次数和内存读/写次数。
由于操作数是存储在内存中的，频繁的执行内存的读/写操作必然影响执行速度。为了解决这个问题，提出了栈顶缓存（TOS，Top-of-Stack Cashing）技术，**将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率**。
 > 指令分派就是当得到当前要执行的指令的opcode（操作码）之后，要跳转到实现该操作码的处理程序的动作。


##### 动态链接（Dynamic  Linking）
 - 每一个栈帧内部都包含一个指向**运行时常量池**中**该帧所属方法的引用**。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。
 - 在java源文件被编译为字节码文件时，所有的变量和方法引用都作为符号引用（Symbolic Reference） 保存在class文件的常量池中。**动态链接的作用就是为了将符号引用转换为调用方法的直接引用**。运行时常量池就是class文件常量池加载到内存中的名称。

 常量池的作用就是提供了一些符号和常量，便于指令的识别。

 ##### 方法的调用
方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还未涉及方法内部的具体运行过程。
在类加载的解析阶段，会将其一部分符号引用转化为直接引用，这种解析能够成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。这类方法的调用被称为解析（Resolution）。（**解析调用一定是一个静态的过期，在编译期间就能完全确定**）。
另一种方法调用形式：分派（Dispatch）可能是静态的也可能是动态的，按照分派依据的宗量数可分为单分派和多分派，这两类分派方式可组成成静态单分派、静态多分派、动态单分派、动态多分派4中分派组合情况。

> 方法的宗量：方法的接收者与方法的参数统称

在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。

 - **静态链接**
 当一个字节码文件被装载进JVM内部时，如果**被调用的目标方法在编译期可知，且运行期保持不变**。这种情况下将调用方法的符号引用转换为直接引用的过程称为静态链接。在Java中符合：**编译期可知，运行期不可变**这个要求的方法，主要有静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，他们都不可能通过继承或者别的方式写出其他版本，因此他们都适合在类加载阶段进行解析。
 - **动态链接**
 如果**被调用的方法在编译期无法被确定下来**，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称为动态链接。

对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。**绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次**。

- **早期绑定**
早期绑定就是指**被调用的目标方法如果在编译期可知，且运行期保持不变时**，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法，因此可以使用静态链接的方式将符号引用转换为直接引用。
- **晚期绑定**
如果**被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相应的方法**，这种绑定方式即为晚期绑定。
> 具备多态特性的编程语言，那么自然也就具备早起绑定和晚期绑定两种方式。


Java中，如果函数不是抽象函数，而是一个普通函数，它是默认实现类似C++中虚函数功能的，也就是说，调用某个函数，是根据当前对象的类型来判断的。

**非虚方法**

- 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的，这样的方法称为非虚方法
- **静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法**
- 其他方法为虚方法

虚拟机中提供了以下几种方法调用指令
* 普通调用指令
1. invokestatic：调用静态方法，解析阶段确定唯一方法版本
2. invokespecial：调用实例构造器的<init>方法、私有及父类方法，解析阶段确定唯一方法版本
3. invokevirtual：调用所有虚方法，用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派）。
4. invokeinterface：调用接口方法，他会在运行时搜索一个实现类这个接口的方法的对象，找出适合的方法进行调用。
* 动态调用指令
5. invokedynamic：动态解析出需要调用的方法，然后执行

前四条指令固化在虚拟机内部，方法的调用执行不可人为执行，而**只要能被invokestatic指令和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，Java语言中符合这个条件的方法共有静态方法、私有方法、实例构造器、父类方法4种，在加上被final修饰的方法（尽管它使用invokevirtual指令调用），这5中方法调用会在类加载的时候把符号引用解析为该方法的直接引用，这些方法统称为非虚方法，其余的方法被称为虚方法**。

###### 动态类型语言和静态类型语言
区别：对类型的检查是在编译期还是在运行期。满足前者就是静态类型语言，反之就是动态类型语言。
更直白地说，**静态类型语言是判断变量自身的类型信息；动态类型语言判断变量值的类型信息，变量没有类型信息，变量值才有类型信息**，这是动态语言的一个重要特征。（Java是静态类型语言，String info = "hello";//info = hello  报错； js：var name = 'hh';var nam = 10;）



静态分派：方法重载                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           		动态分派：方法重写 
	（书籍303 ）

> 所有依赖静态类型来决定方法执行版本的分派动作，称为静态分派。静态分派的最经典应用表现就是方法重载。静态分派发生在编译阶段。
>
> 在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。最经典的应用表现就是方法重写，发生在运行期。根源于虚方法调用指令invokevirtual的执行逻辑。

###### Java中方法重写的本质（invokevirtual指令的运行时解析过程）
1、找到一个操作数栈栈顶的第一个元素所执行的对象的**实际类型**，记作C。
2、如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限的校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回`java.lang.IllegalAccessError`异常。
3、若没有找到相符的方法，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程，
4、如果始终没有找到合适的方法，则抛出`java.lang.AbstractMethodError` 异常。

> **IllegalAccessError**：程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般来说，会引起编译器异常。这个错误如果发生在运行时，就说明发生了一个不兼容的改变。

在面向对象的编程中，会很频繁的使用到动态分派，如果每次动态分配的过程中都要重新在类的方法元数据中搜索合适的目标的话就**会影响执行效率。因此，为了提高性能，JVM采用在类的方法区中建立一个虚方法表（virtual method table）(非虚方法不会出现在表中)来实现。使用索引表来实现**。

每一个类中都有一个虚方法表，表中存放着各个方法的实际入口。
虚方法表会在类的加载阶段被创建并初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完成。

#### 方法返回地址（Return Address）
当一个方法开始执行后，只有两种方式退出这个方法。
1、执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者，方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为：**正常调用完成**。
2、在方法执行过程中遇到了异常，这个异常没有在方法体内的到妥善处理。无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。这种退出方法的方式称为：**异常调用完成**。

无论哪种方法，在方法退出之后，都必须返回到最初方法被调用时的位置。 方法返回时，可能需要栈帧中保存一些信息，用来帮助恢复它的上层主调方法的执行状态。**一般来说，方法正常退出时，主调方法的PC计数器的值可以作为返回地址，栈帧中很有可能保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧就一般不会保存这部分信息**。

方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令的后面的一条指令等。

#### 附加信息
栈帧中还允许携带一些与Java虚拟机实现相关的一些附加信息，如与调试、性能收集相关的信息。

### 本地方法接口
#### 什么是本地方法接口？
简单地讲，一个native method 就是一个Java调用非Java代码的接口。一个native method就是这样一个方法 ：该方法的实现由非Java实现。也就是说，native method 有方法体，不过并不是由java实现。标识符可以与所有其它的java标识符连用，但abstract除外。（抽象方法是没有方法体的，而native mthod 是有方法体的）

### 本地方法栈
- java虚拟机栈用于管理java方法的调用，而本地方法栈用于管理本地方法的调用。
- 线程私有
- 允许被实现成固定或者可动态扩展的大小
- 具体做法是native method stack中登记native方法，在Execution Engine执行时加载本地方法库
- 当某一个线程调用一个本地方法时，它就进入一个全新的且不再受虚拟机限制的世界，它和虚拟机拥有同样的权限
    - 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区
    - 它甚至可以直接使用本地处理器中的寄存器
    - 直接从本地内存的堆中分配任意数量的内存

### 1 StackOverflow

每当java程序启动一个新的线程时，java虚拟机会为他分配一个栈，java栈以帧为单位保持线程运行状态；当线程调用一个方法时，jvm压入一个新的栈帧到这个线程的栈中，只要这个方法还没返回，这个**栈帧**就存在。
如果方法的嵌套调用层次太多(如递归调用),随着java栈中的帧的增多，最终导致这个线程的栈中的所有栈帧的大小的总和大于-Xss设置的值，而产生StackOverflowError溢出异常。

### 2 OutOfMemory

#### 2.1 堆内存溢出

java堆用于存放对象的实例，当需要为对象的实例分配内存时，而堆的占用已经达到了设置的最大值(通过-Xmx)设置最大值，则抛出OutOfMemoryError异常。

#### 2.2 栈内存溢出

java程序启动一个新线程时，没有足够的空间为该线程分配java栈，一个线程java栈的大小由-Xss设置决定；JVM则抛出OutOfMemoryError异常。

#### 2.3 方法区内存溢出

方法区用于存放java类的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。在类加载器加载class文件到内存中的时候，JVM会提取其中的类信息，并将这些类信息放到方法区中。
当需要存储这些类信息，而方法区的内存占用又已经达到最大值（通过-XX:MaxPermSize）；将会抛出OutOfMemoryError异常。


### 堆
- 一个JVM实例只存在一个堆内存，堆也是java内存管理的核心区域
- Java堆区在 JVM启动的时候被创建，其空间大小也确定了。（大小可调节）
- 堆可以处于物理上不连续的内存空间，但在逻辑上应该被视为连续的
- 所有的线程共享java堆 ，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer,TLAB）
- 所有的对象实例以及数组都**应当**在运行时分配在堆上。
- 数组和对象可能永远不会存储在栈上，因为栈帧保存引用，这个引用指向对象或数组在堆中的位置
- 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除
- 堆，是GC执行垃圾回收的重点区域 

#### 设置堆的内存大小与OOM
- Java堆用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了， 可以通过“-Xmx”和“-Xms”来进行设置。
    - “-Xms”用于表示堆区(年轻代+老年代)的起始内存，等价于-XX：InitialHeapSize
    - "-Xmx" 则用于表示堆区(年轻代+老年代)的最大内存，等价于-XX：MaxHeapSize
- 一旦堆区的内存大小超出“-Xmx”所指定的最大内存时，将会抛出OOM异常。
- 通常会将-Xms 和 -Xmx 配置为相同的值，其目的是为了能够**在java垃圾回收机制清理完堆区后不需要重新分割计算堆区的大小，从而提高性能**。
- 默认情况下。初始内存大小： 物理电脑内存大小 / 64
                  最大内存大小：物理内存大小 / 4
- 查看设置的参数
       方式一、jps / jstat -gc 进程id
       方式二、-XX:+PrintGCDetails
 ```java
public class Heap {
    public static void main(String[] args) {
        //返回java虚拟机中的堆内存总量
        long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;
        //返回Java虚拟机试图使用的最大堆内存量
        long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;

        System.out.println("-Xms:" + initialMemory + "M");
        System.out.println("-Xmx:" + maxMemory + "M");

        System.out.println("系统的内存大小为:" + initialMemory * 64.0 / 1024 + "G");
        System.out.println("系统的内存大小为:" + maxMemory * 4.0 / 1024 + "G");
    }
}

 ```
![image-20201212074040370](http://image.yzqfrist.com/20201212074049.png)


#### 年轻代与老年代
- 存储在JVM中的Java对象可以被划分为两类：
     - 生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速
     - 生成周期很长的对象，在某些极端情况下还能够与JVM的生命周期保持一致

- Java堆细分的话，可以分为年轻代（YoungGen）和老年代（OldGen）

![堆](http://image.yzqfrist.com/20201212232735.png)

- 配置新生代与老年代在堆结构的占比。
    - 默认-XX：NewRatio=2,表示新生代占1，老年代占2
    - 可以修改-XX：NewRatio=4,表示新生代占1，老年代占4

- 在HotSpot,Eden和另外两个Survivor空间缺省值为8:1:1，可以通过-XX： SurvivorRatio调整
- 几乎所有的Java对象都是在Eden区被new出来的。
- -XX:NewRatio 设置新生代与老年代的比例，默认为2
- -XX:SurvivorRatio 设置新生代Eden区与Survivor区的比例
- -XX：-UseAddaptiveSizePolicy 关闭自适应内存分配策略（暂时用不到）
- -Xmn 设置新生代的空间的大小（一般不设置）

#### 对象分配过程
1、new的对象先放在Eden区，此区有大小限制
2、当Eden区的空间填满时，程序又需要创建对象，JVM的垃圾回收器将Eden进行垃圾回收（Minor GC），将Eden区中的不再被其他对象所引用的对象进行销毁，再加载新的对象放到Eden区。
3、然后将Eden区的剩余对象移动到Survivor0区。
4、如果再次触发垃圾回收，此时上次幸存下来的放在S0（Survivor0）区的，如果没有回收，就会放到S1区。
5、 如果再次经历垃圾回收，此时会重新放回S0。
6、默认15次后提升到old区。-XX:MaxTenuringThreshold=<N>设置。
7、当old区内存不足时，再次触发GC：Major GC , 进行old区的内存清理
8、若old区执行Major GC后发现依然无法进行对象的保存，就会产生OOM异常。
![对象分配过程](http://image.yzqfrist.com/20201214072720.png)


#### Minor GC 、Major GC 与 Full GC
JVM在进行GC时，并非每次都对新生代、老年代、方法区一起回收，大部分回收的都是新生代。
针对HotSpot VM 实现，GC按照回收区域划分为部分收集（Partial GC）和 整堆收集（Full GC）。
- 部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：
    - 新生代收集（Minor GC / Young GC）：只是新生代的垃圾收集。
    - 老年代收集（Major GC / Old GC）: 只是老年代的垃圾收集。
        - 目前，还有CMS GC会有单独收集老年代的行为。
        - 注意，很多时候Major GC和Full GC混淆使用，需要辨析是老年代回收还是整堆回收。      
     - 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。
        - 目前，只有G1 GC 会有这种行为。
- 整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集。

##### 年轻代GC（Minor GC）触发机制
- 当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden区满，Survivor满不会触发 GC。（每次Minor GC会清理年轻代的内存）
- Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，回收速度也快。
- Minor GC会引发STW，暂停其他用户线程，等垃圾回收结束，用户线程才会恢复运行。
##### 老年代GC （Major GC / Full Gc ）触发机制
- 出现Major  GC经常会伴随至少一次的Minor GC（并非绝对，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC策略的选择过程）
    - 也就是老年代空间不足时，会先尝试触发Minor GC。如果之后空间还是不足，会触发Major GC。
 - Major GC 的速度一般会比Minor GC慢10倍以上，STW时间更长
 - 如果Major GC后空间还是不足，就报OOM。
##### Full GC触发机制
触发Full GC的情况有以下五种：
1. 调用System.gc()时，系统建议执行Full GC，但不必然执行。
2. 老年代空间不足。
3. 方法区空间不足。
4. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存。
5. 由Eden区、Survivor space0(from space)区向survivor space1(to space)区复制时，对象大小大于to space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。
####  内存分配策略（或对象提升（Promotion）规则）
如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能够被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设置为1。对象在Survivor区没熬过一次Minor GC ，年龄就增加一岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM，每个GC都有所不同）时，就会晋升到老年代。

对象晋升的年龄阈值，可以通过 **-XX:MaxTenuringThreshold** 来设置。

针对不同年龄的对象的分配原则如下：
- 优先分配到Eden区
- 大对象直接分配到老年代
- 长期存活的对象分配到老年代
- 动态对象年龄判断
    - 如果Survivor区中相同年龄的所有对象的大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold 中要求的年龄。
- 空间分配担保
    - -XX:HandlePromotionFailure
#### TLAB
##### 为什么有TLAB（Thread Local Allocation Buffer）?
- 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据
- 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区划分内存空间是线程不安全的
- 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度

##### 什么是TLAB？
- 从内存模型来看，对Eden区继续进行划分，**JVM为每一个线程分配了私有缓存区域**，它包含在Eden空间内。
- 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此可以将这种内存分配方式称为**快速分配策略**。
##### TLAB再说明
- 尽管不是所有的对象实例都能够在 TLAB中成功分配内存，但**JVM确实是将TLAB作为内存分配的首选**。
- 在程序开发中，可以通过 **-XX:UserTLAB**设置是否开启TLAB空间。
- 默认情况下，TLAB空间的内存非常小，**仅占有整个Eden区的1%**，可以通过选项 **-XX:TLABWasteTargetPercent**设置TLAB空间所占用Eden空间的百分比大小。
- 一旦对象在TLAB空间分配内存失败时，JVM就会尝试通过使用**加锁机制**确保数据操作的原子性，从而直接在Eden空间中分配内存。

![对象分配过程-TLAB](http://image.yzqfrist.com/20201214222022.png)


#### 小结堆空间的参数设置
- -XX:+PrintFlagsInitial：查看所有参数的默认初始值
- -XX:+PrintFlagsFinal：查看所有参数的最终值
- -Xms：初始堆空间内存（默认为物理内存的1/64）
- -Xmx：最大堆空间内存（默认为物理内存的1/4）
- -Xmn：设置新生代的大小。（初始值及最大值）
- -XX:NewRatio：设置新生代与老年代在堆结构的占比。
- -XX:SurvivorRatio：设置新生代中的Eden和S0/S1空间的比例
- -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄
- -XX：PrintGCDetails：输出详细的GC日志
    - 打印简要信息：1. -XX:+PrintGC 2. -verbose:gc

- -XX:HandlePromotionFailure：是否设置空间分配担保
  在发生MinorganicGC前，虚拟机会**检查老年代最大可用连续空间是否大于新生代所有对象的总空间**。
    - 如果大于，则此次Minor GC是安全的。
    - 如果小于，虚拟机会检查 -XX:HandlePromotionFailure设置是否允许担保失败。
        - 如果为true， 那么会继续**检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小**。
            - 如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的。
            - 如果小于，则改为进行一次Full GC。
            
       - 如果为false，则改为进行一次Full GC。

在 JDK7后，HandlePromotionFailure不再使用，规则变为只要**老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小**就会进行Minor GC，否则进行Full GC。

#### 堆是分配对象存储的唯一选择吗？

随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术让所有对象都分配到堆上也逐渐变得不那么“绝对”了。

在Java虚拟机中，对象是在Java堆中分配内存的。但是，有一种特殊情况，那就是**如果经过逃逸分析（ Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就有可能被优化成栈上分配**。这样就无需在堆上分配，也无须GC，这就是最常见的堆外存储技术。

##### 逃逸分析概述
- 如何将堆上的对象分配到栈，需要使用逃逸分析手段。
- 这是一种可以有效减少Java程序中同步负载和内存堆压力的跨函数全局数据流分析算法。
- 通过逃逸分析，Java HotSpot 编译器能够分析出一个新的对象的引用的使用范围，从而决定是否要将这个对象分配到堆上。
- 逃逸分析的基本行为就是分析对象动态作用域：
    - 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸
    - 当一个对象在方法中被定义后它被外部方法引用，则认为发生逃逸。

- 没有发生逃逸的对象， 则可以分配到栈上，随着方法执行的结束，栈空间被移除。
```java
//new的对象实体是否有可能在方法外调用
public class EscapeAnalysis {
    public  EscapeAnalysis obj;

    //方法返回EscapeAnalysis对象，发生逃逸
    public EscapeAnalysis getInstance(){
        return obj == null ? new EscapeAnalysis() : obj;
    }

    //为成员变量赋值，发生逃逸
    public void setObj(){
        this.obj = new EscapeAnalysis();
    }
    //思考：如果obj引用声明为static的？ 仍然逃逸
    
    //对象的作用域仅在当前方法中有效，没有发生逃逸
    public void userEscapeAnalysis(){
        EscapeAnalysis e = new EscapeAnalysis();
    }

    //引用成员变量的值，发生逃逸
    //  new的对象实体 发生了逃逸  ，关心的实体，不是变量e , e是在局部变量表中
   // getInstance().xxx 同样发生逃逸
    public void userEscapeAnalysis1(){
        EscapeAnalysis e = getInstance();
    }
}
```

使用逃逸分析，编译器可以对代码做如下分析：
一、**栈上分配**。将堆分配转化为栈分配。如果一个对象在子程序中被分配。要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。

二、**同步省略**。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。

三、**分离对象或标量替换**。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。

##### 代码优化之栈上分配
- JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。
- 常见的**非栈上分配**的场景
    - 成员变量赋值、方法返回值、实例引用传递

##### 代码优化之同步省略
- 线程同步的代价是相当高的，同步的后果就是降低并发性和性能。
- 在动态编译同步块的时候，JIT编译器可以借助逃逸分析来**判断同步块所使用的锁对象是否只能够被一个线程访问而没有发布到其他线程**。如果没有，那么 JIT编译器在编译这个同步块的时候就会取消这部分代码的同步，这个取消同步的过程就叫同步省略，也叫锁消除。

##### 代码优化之标量替换
标量（Scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫作聚合量（Aggregate），Java中的对象就是聚合量。
在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问到的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替，这个过程就是标量替换。通过标量替换，可以大大减少堆内存的占用。因为一旦不需要创建对象了，就不再需要分配堆内存了。

> -XX:+EliminateAllocations：开启标量替换（默认开启），允许将对象打散分配到栈上
> -server:启动server模式，因为在server模式下，才可以启用逃逸分析

#### 逃逸分析小结
逃逸分析技术还不成熟，其根本原因是**无法保证逃逸分析的性能消耗，虽然经过逃逸分析可以做标量替换、栈上分配和锁消除，但是逃逸分析自身也需要进行一系列复杂的分析，这也是一个相对耗时的过程**。

注意一些观点，认为通过逃逸分析，JVM在栈上分配那些不会逃逸的对象，在理论上可行的，但HotSpot并未那么做，所以可以明确**所有的对象实例都是创建在堆上的**。 ---- 否定之否定

### 方法区

![堆、栈、方法区的关系](http://image.yzqfrist.com/20201215221127.png)

#### 方法区的理解

《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩”。对于HotSpotJVM而言，方法区还有一个别名，叫作Non-Heap（非堆）。

- 方法区和堆一样，是各个线程共享的内存区域
- 方法区在JVM启动的时候被创建，并且它的实际的物理内存空间和Java堆区一样都是可以不连续的。
- 方法区的大小和堆一样，可以选择固定大小或者可扩展。
- 方法区的大小决定了系统可以保存多少个类。
- 关闭JVM就会释放这个区域的内存。
- 在JDK7以前，方法区也被称为永久代。JDK8开始，使用元空间取代了永久代。
- 元空间和永久代类似，都是方法区的实现。不过元空间和永久代最大的区别是：**元空间不在虚拟机设置的内存中，而是使用本地内存**。

##### JDK8后设置方法区内存大小
- -XX:MetaspaceSize和-XX:MaxMetaspaceSize指定。
- 默认依赖于平台，windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。
- -XX:MetaspaceSize： 设置元空间的初始值大小。这就是初始的高水位线，一旦触及这个水位线，Full GC 将会被触发并卸载没用的类（即这些类的类加载器不再存活），然后这个高水位线会被重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过-XX:MaxMetaspaceSize时，适当提高该值，如果释放空间过多，则适当降低该值。
- 如果初始化的高水位线设置过低，Full GC会被多次调用。为了避免频繁GC，建议将-XX:MetaspaceSize设置为一个较高的值。

#### 方法区的内部结构

##### 方法区存储什么
方法区用于存储已被虚拟机加载的**类型信息、常量、静态变量、即时编译器编译后的代码缓存、域信息、方法信息**等。

###### 类型信息
对每个加载的类型（类Class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：
①、这个类型的完整有效名称（全名=包名.类名）
②、这个类型直接父类的完整有效名
③、这个类型的修饰符（public、 abstract、final的某个子集）
④、这个类型直接接口的一个有序列表

###### 域（Field）信息
- JVM必须在方法区中保存类型的所有的域的相关信息以及域的声明信息。
- 域的相关信息包括：域名称、域类型、域修饰符（public 、private、protected、static、final、volatile、transient的某个子集）。
###### 方法（method）信息
JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：
- 方法名称
- 方法的返回类型
- 方法的参数数量和类型（按顺序）
- 方法的修饰符
- 方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）
- 异常表（abstract和native方法除外）
    - 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引
##### 常量池（字节码文件中）
几种在常量池中存储的数据类型包括：数量值、字符串值、类引用、方法引用、字段引用。
常量池可以看做一张表，虚拟机根据这张表找到要执行的类名、方法名称、参数类型、字面量等类型。

##### 运行时常量池（方法区中）
- **常量池表是class文件的一部分，用于存放编译期生成的各种找字面量和符号引用，这部分内容在类加载后存放到方法区的运行时常量池中**。
- JVM为每个已加载类型都维护一个常量池。池中的数据项像数组项一样，是通过**索引访问**的。
- 运行时常量池中包含多种不同的常量，包括编译期就已知的数值字面量，也包括到运行期解析后才能获得的方法或者字段引用，此时不再是常量池中的符号地址，这里换为真实地址。
    - 运行时常量池，相对于class文件常量池的另一个重要特征就是：具备动态性 String.intern()
- 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OOM异常
#### 方法区的演进
HotSpot中方法区的变化：

| JDK版本        | 方法区                                                       |
| -------------- | ------------------------------------------------------------ |
| jdk1.6及在之前 | 有永久代（Permanent generation）,静态变量存放在永久代上      |
| jdk1.7         | 有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中 |
| jdk1.8及以后   | 无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆 |

![方法区JDK6](http://image.yzqfrist.com/20201217074021.png)
![方法区JDK7](http://image.yzqfrist.com/20201217074023.png)
![方法区JDK8](http://image.yzqfrist.com/20201217074026.png)

类的元数据被移到一个与堆不相连的本地内存区域，即元空间。由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。
这项改动是很有必要的：
1） 为永久代设置空间大小是很难确定的
2） 对永久代进行调优是很困难的

#### 方法区的垃圾收集
方法区的垃圾回收主要回收两部分内容：常量池中废弃的常量和不再使用的类型。

- 方法区中常量池之中主要存放的两大类常量：字面量和符号引用。符号引用包括：1、类和接口的全限定名。 2、字段的名称和描述符 3、方法的名称和描述符。

- HotSpot虚拟机对常量池的回收策略是，只要常量池中的常量没有被任何地方引用，就可以被回收。
- 判断一个类型是否属于“不再被使用的类”的条件比比较严苛。
    - 该类的所有实例都已经被回收，也就是java堆中不存在该类和其任何派生子类的实例
    - 加载该类的类加载器已经被回收。
    - 该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射来访问该类的方法。
- Java虚拟机**允许**对满足上三个条件的无用类进行回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-noclassgc参数进行控制，还可以使用-verbos:class以及-XX:+TraceClass-Loading、-XX:+TraceClassUnLoding查看类加载和卸载信息。


### 对象的实例化、内存布局与访问定位

#### 对象的实例化
[脑图](https://app.yinxiang.com/shard/s43/nl/30056274/59a64fa4-8a98-41dd-911e-9d1fc8501c1a)
![对象实例化](.\image\JVM\20201220184921.png)

总结：对象实例化的过程
①、加载类元信息
②、为对象分配内存
③、处理并发问题
④、属性默认初始化（零值初始化）
⑤、设置对象头信息
⑥、属性的显示初始化、代码块中的初始化、构造器中初始化

#### 对象内存布局
[对象的内存布局脑图](https://app.yinxiang.com/shard/s43/nl/30056274/142d7f09-fa17-41e4-8c46-8c28f34ef73d)

![内存布局](.\image\JVM\20201220185944.png)

##### 图示内存布局
```java
public class Customer {
    public static void main(String[] args) {
        Customer cust = new Customer();
    }
}
```
![图示对象内存布局](.\image\JVM\20201220193854.png)

#### 对象访问定位

 JVM是如何通过栈帧中的对象引用访问到其内部的对象实例的呢？
 ![对象访问定位](.\image\JVM\20201220204455.png)

[内存访问方式脑图](https://app.yinxiang.com/shard/s43/nl/30056274/8f0f9e7c-9904-4569-9b5e-854fb5c72524)

![对象访问定位脑图](.\image\JVM\20201220215549.png)

句柄访问定位

![句柄访问](http://image.yzqfrist.com/%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.png)

直接指针

![直接指针定位（HotSpot默认）](http://image.yzqfrist.com/%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E5%AE%9A%E4%BD%8D%EF%BC%88HotSpot%E9%BB%98%E8%AE%A4%EF%BC%89.png)




#### 直接内存

- 存在OOM，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。
- 缺点：1、分配回收成本较高 2、不受JVM内存回收管理
- 直接内存大小可以通过MaxDriectMemorySize设置
- 如果不指定，默认与堆的最大值-Xmx参数值一致

### 执行引擎

执行引擎在执行字节码的时候，通常会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择。
		

在![编译过程](http://image.yzqfrist.com/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png)Java中，javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在java虚拟机之外进行的，而解释器在虚拟机的内部，所以java程序的编译是半独立的实现。

问题：什么是解释器（ Interpreter），是么是JIT编译器？
解释器：当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码翻译为对应平台的本地机器指令执行。
JIT编译器（Just In Time Complier）：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。

解释器优点：启动迅速；节约内存

HotSpot采用解释器与即时编译器**并存**的架构。
原因：当Java虚拟机启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，根据热点探测功能，将有价值的字节码编译成本地机器指令，以获得更高的执行效率。同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的的“逃生门”（逆优化）。

![解释器与编译器的交互](http://image.yzqfrist.com/%E8%A7%A3%E9%87%8A%E5%99%A8%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%BA%A4%E4%BA%92.png)

> 前端编译器：把.java文件转变为.class文件
> 后端运行期编译器（JIT编译器）：把字节码转换为机器码。
> 静态提前编译器（AOT编译器）：程序运行前，直接将.java文件编译成本地机器代码。

#### 热点代码与触发条件
即时编译器编译的目标是热点代码，主要有两类，
- 被多次调用的方法。
- 被多次执行的循环体。
对于这两种情况，编译的目标对象都是整个方法体。

判断某段代码是不是热点代码的行为成为热点探测。主流的热点探测方式有
- 基于采样的热点探测
- 基于计数器的热点探测（HotSpot采用）

基于计数器的热点探测会为每个方法准备两类计数器：**方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）**。
 - 方法调用计数器用于统计方法的调用次数。
 - 回边计数器则用于统计循环体执行的循环次数。

 当虚拟机运行参数确定的前提下，这两个计数器都有一个明确地阈值，计数器阈值一旦溢出，就会触发即时编译。

##### 方法调用计数器
统计方法的调用次数，默认阈值：client模式  1500  server模式 10000次
可通过 **-XX:CompliThreshold** 设置。

当一个方法被调用时，虚拟机会先检查该方法 是否存在被即时编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将该方法的调用计数器值加一，然后判断方法调用计数器和回边计数器值之和是否超过方法调用计数器的阈值。一旦超过阈值的话，将会向即时编译器提交一个该方法的代码编译请求。
![方法调用计数器触发即时编译](http://image.yzqfrist.com/20201223075010.png),进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 **-XX：-UseCounterDecay**来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样只要系统运行时间足够长，程序中绝大部分方法都会被编译成本地代码。另外可以使用 **-XX:CounterHalfLifeTime**参数设置半衰周期的时间，单位是秒。

 #### 回边计数器

 作用：统计一个方法中循环体代码执行的次数。建立回边计数器统计的目的是为了触发栈上的替换编译（OSR）；

 当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的版本，如果有的话，它将会优先执行已编译的代码，否则就把回边计数器的值加一，然后判断方法调用计数器与回边计数器值之和是否超过回边计数器的阈值。当超过阈值的时候，将会提交一个栈上替换编译请求，并且把回边计数器的值稍微降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果。
![回边计数器触发即时编译](http://image.yzqfrist.com/20201223075004.png)

与方法计数器不同，回边计数器没有技术热度衰减的过程，因为回边计数器统计的是方法循环执行的绝对次数。当计数器溢出的时候，它还会将方法计数器的值也调整到溢出状态，这样下次再进入该方法的时候就会执行标准编译过程。

#### HotSpot VM中JIT的分类
##### C1和C2
在HotSpot VM中内嵌两个JIT编译器，分别为Client Compiler（C1）和Server Compiler（C2）。

运行时指定：
- -client:指定java虚拟机运行在Client模式下，并使用C1编译器
    - C1编译器会对字节码进行**简单和可靠的优化，耗时短**。以达到更快的编译速度。
    
- -server：指定虚拟机运行在server模式下，并使用C2编译器。
    - C2进行**耗时较长的优化，以及激进优化**。但优化的代码执行效率更高。

##### C1和C2编译器不同的优化策略
C1编译器上主要有方法内联、去虚拟化、冗余消除。
- 方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程。
- 去虚拟化：对唯一的实现类进行内联。
- 冗余消除：在运行期间把一些不会执行的代码折叠掉。

C2的优化主要在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化。
- 标量替换：用标量值代替聚合对象的属性值。
- 栈上分配：对于未逃逸的对象分配对象在栈而不是堆。
- 同步消除：清除同步操作，通常指 synchronized

### String Table
#### 字符串拼接操作
1、常量与常量的拼接结果在常量池，原理是编译器优化。
2、常量池中不会存在相同内容的常量。
3、只要其中有一个变量，结果就在堆中。变量拼接的原理是StringBuilder。
4、如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址。

字符串拼接操作不一定使用的都是StringBuilder方式。。如果拼接符号左右两边都是**字符串常量或常量引用**，则仍使用编译器优化，即非StringBuilder方式。
针对于final修饰类、方法、 基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。
![image-20201225071854207](http://image.yzqfrist.com/20201225071856.png)

```java
public class Test {
    public static void main(String[] args) {
        plusStr(10000);
        stringbuilderPlusStr(10000);
    }

    /** 耗时：803
     * + 执行拼接操作：
     * ① 每次 + 操作都会导致底层新建一个StringBuilder对象和一个String 对象
     * ② 如果堆内存设置太小，会导致频繁GC
     * @param times
     */
    public static void plusStr(int times){
        String s1 = "beijing";
        long startTime = System.currentTimeMillis();
        for (int i = 0; i < times; i++) {
            s1 += "beijing";
        }
        long endTime = System.currentTimeMillis();
        System.out.println(endTime - startTime);
    }

    /**耗时：1
     * StringBuilder 执行拼接操作
     *  好处：从始至终就创建了一个StringBuilder对象，去执行append 操作
     *
     *  改进空间： 可使用StringBuilder的指定大小的构造器。
     *  如果使用默认构造器，初始容量16，容量不足时会进行扩容，将原来的对象的内容进行copy，中间也会产生垃圾对象。
     * @param times
     */
    public static void stringbuilderPlusStr(int times){
        StringBuilder builder = new StringBuilder("beijing");
        long startTime = System.currentTimeMillis();
        for (int i = 0; i < times; i++) {
           builder.append("beijing");
        }
        long endTime = System.currentTimeMillis();
        System.out.println(endTime - startTime);
    }

}

```

#### intern()的使用
如果不是用双引号声明的String对象，可以使用String提供的intern方法：
> When the intern method is invoked, if the pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned. Otherwise, this String object is added to the pool and a reference to this String object is returned.
> 调用intern方法时，如果池已经包含等于equals（Object）方法确定的此String对象的字符串，则返回池中的字符串。否则，将此String对象添加到池中，并返回对此String对象的引用
```java
("a"  + "b" +"c").intern() == "abc"
```
通俗点说，intern确保String字符串在内存中只存在一份内存拷贝，从而节约内存空间，加快字符操作任务的执行速度。
例子：（jdk8）

```java
public class InternTest {
    public static void main(String[] args) {

        /**
         * ① String s = new String("a");
         *  创建了两个对象
         *      堆空间中的一个new对象
         *      字符串常量池中的一个字符串常量"a" (看字节码）
         * ②   s.intern();由于字符常量池中有“a"  返回字符串“a"
         */
        String s = new String("a");
        s.intern();
        String s2 = "a";
        System.out.println(s == s2); //false

        /** ① String s3 = new String("a") +new String("b");
         *      常量池中并不会生成字符串“ab"
         *  ②   s3.intern(); 常量池中并无“ab" 故将string对象添加到池中，
         *  并返回String对象的引用
         *
         */
        String s3 = new String("a") +new String("b");
        s3.intern();
        String s4 = "ab";
        System.out.println(s3 == s4);//true

    }
}
```
总结：
1、如果串池中有，则并不会放入。返回已有的串池中的对象的地址。
2、如果没有，则会把**对象的引用地址复制一份**，放入串池，并返回串池中的引用地址。

![image-20201227135028905](http://image.yzqfrist.com/20201227135039.png)


### 垃圾回收GC相关算法
垃圾是指在运行程序中没有任何指针指向的对象。

#### 对象已死？
##### 引用计数算法（Reference Counting）
- 对每个对象保存一个整型的**引用计数器**属性。用于记录对象被引用的情况
- 每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的，可进行回收。

使用此算法的语言：Python

###### 优缺点
- **优点**：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。
- **缺点**：
    - 它需要单独的字段存储计数器，增加了存储空间的开销。
    - 每次赋值都需要更新计数器，伴随着加法和减法的操作，增加了时间开销。
    - **无法处理循环引用**（最为致命）   --- 是否可以采用拓扑排序算法

循环引用举例
```java
public class ReferenceCountingGC {
    public Object instance = null;

    private static final int _1MB = 1024 * 1024;
    /**
     * 这个成员属性的唯一意义就是占用内存，以便能在GC日志看清楚中是否有回收过
     */
    private byte[] bigSize = new byte[2 * _1MB];

    public static void main(String[] args) {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;

        objA = null;
        objB = null;

        System.gc();
    }
}
```
```
[GC (System.gc()) [PSYoungGen: 9339K->776K(76288K)] 9339K->784K(251392K), 0.0028618 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (System.gc()) [PSYoungGen: 776K->0K(76288K)] [ParOldGen: 8K->688K(175104K)] 784K->688K(251392K), [Metaspace: 3478K->3478K(1056768K)], 0.0073343 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
```

从内存回收日志可见“9339K->784K”，意味着虚拟机并没有因为这两个对象互相引用就放弃会收它们，这也侧面说明了java虚拟机并不是通过引用计数算法来判断对象是否存活的。
##### 可达性分析算法（Reachability Analysis）
当前主流的商用语言（Java、C#）的内存管理子系统，都是通过可达性分析算法来判断对象是否存活的。
###### 基本思路
- 通过一系列称为“GC Roots”的根对象作为起始节点集，按照从上向下的方式搜索**根对象集合所连接的目标对象是都可达**。
- 搜索过程所走过的路径称为“引用链”（Reference Chain）。如果某个对象到GC Roots间没有任何引用链相连（图论中话即GC Roots到这个对象不可达），则证明此对象是不可能再被使用的，可标记为垃圾对象。
- 在可达性分析算法中，只有能够被根对象集合直接或间接连接的对象才是存活对象。

![可达性分析算法](http://image.yzqfrist.com/20201228205642.png)


###### GC Roots
在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：
- 在虚拟机栈（栈帧的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
- 在方法区中类静态属性所引用的对象，譬如Java类的引用类型静态变量。
- 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
- 在本地方法栈中JNI（即通常说的Native方法）引用的对象。
- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常（如NullPointException、OutOfMemoryError）等，还要系统类加载器。
- 所有被同步锁（synchronized 关键字）持有的对象。
- 反映Java虚拟机内部情况的JMXBean、本地代码缓存等。
除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。

如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性快照中进行。这点不满足的话分析结果的准确性就无法保证。
这点也是导致GC进行时必须“Stop The World”的一个重要原因。即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根结点时也是必须要停顿的。

> 小技巧：由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。


##### 再谈引用
![引用类](http://image.yzqfrist.com/20201229201107.png)
Java中强引用分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）。这四种引用的强度依次减弱。
- **强引用**：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object object = new Object()”这种引用关系。**无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象**。（普通系统99%以上都是强引用）强引用是造成内存泄漏的主要原因之一。
- **软引用**：用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，**在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收**，如果这次回收还没有足够的内存，才会抛出内存溢出异常。java提供了SoftReference类来实现软引用。
```java
Object object = new Object();
SoftReference<Object> sf = new SoftReference<>(object);
object = null; //销毁强引用
```
- **弱引用**：也是用来描述哪些非必须对象，但它的强度比软引用更弱一些。被弱引用关联的对象只能生存到下一次垃圾收集发生为止。**当垃圾收集器开始工作，无论当前内存是否足够，都会回收只被弱引用关联的对象**。Java提供了WeakReference类来实现弱引用。
- **虚引用**：也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。Java提供了PhantomReference类来实现虚引用。虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾收集器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。由于虚引用以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。

```java
Object object = new Object();
ReferenceQueue<Object> objectReferenceQueue = new ReferenceQueue<>();
PhantomReference<Object> phantomReference = new PhantomReference<>(object, objectReferenceQueue);
object = null; 
```
> 总结：强引用不回收，软引用内存不足即回收，弱引用发现即回收，虚引用对象回收跟踪。

##### 对象的finalization机制
- Java语言提供了对象终止（finalization）机制来允许开发人员**提供对象被销毁之前的自定义处理逻辑**。
- 当垃圾收集器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。
- finalize（）方法允许在子类中被重写，用于在对象被回收时进行资源释放。
- 永远不要主动调用某个对象的finalize（）方法，应该交给垃圾回收机制调用。理由如下：
    - 在finalize（）时可能会导致对象复活
    - finalize（）方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize（）方法将没有执行机会。
    - 一个糟糕的finalize（）会严重影响GC的性能。
- 即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”，这时候它们暂时还处于“缓刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么对它的回收就是不合理的，为此，先定义虚拟机中的对象可能的三种状态：
    - 可触及的：从根节点开始，可以到达这个对象。
    - 可复活的：对象的所有引用被释放，但是对象可能在finalize（）中复活。
    - 不可触及的：对象的finalize（）被调用，并且没有复活。不可触及的对象不可能被复活，因为finalize（）只会被调用一次。  **只有在对象不可触及时才可以被回收。**
##### 判定对象是否可回收
判断一个对象objA是否可回收，至少要经历两次标记过程：
    1.如果对象objA到GC Roots 没有引用链，则进行第一次标记。
    2.随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。
        ①、如果对象objA没有重写finalize()方法，或者finalize()方法已被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。
        ②、如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发器finalize()方法执行。
        ③、finalize()方法是对象逃脱死亡的最后机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记它时它将被移出“即将回收”集合。之后，对象再次出现没有引用存在的情况，在这个情况下，finalize()方法不会再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize()方法只会被调用一次。
        

### 垃圾收集算法
#### 分代收集理论
分代收集（Generational Collection）建立在三个分代假说之上：
1）弱分代假说：绝大多数对象都是朝生夕灭的。
2）强分代假说：熬过越多次垃圾收集过程的对象就越难消亡。
3）跨代引用假说：跨代引用相对于同代来说仅占极少数。（存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。）

前两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。
对于第三个假说，则是因为加入要进行一次只局限于新生代区域的收集，但新生代中的对象完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中的所有对象来确保可达性分析结果的正确性。但遍历老年代会为内存回收带来很大的性能负担。基于跨代引用假说，在新生代上建立一个全局的数据结构（**记忆集** Remembered Set），这个结构把老年代划分为若干块，**标识出老年代的哪一块内存会存在跨代引用**。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。

 #### 标记-清除算法（Mark-Sweep）
 ##### 核心思想
 当堆中的有效内存空间被耗尽的时候，就会停止整个程序（Stop the world），然后进行两项工作，第一项是标记，第二项则是清除。
  - 标记：Collector从引用根节点开始遍历，标记所有被引用的对象。（或者标记没有被引用的对象）
  - 清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象没有标记为可达对象，则将其回收。

  ![jvm标记清除算法](http://image.yzqfrist.com/20210103110136.png)

  ##### 缺点
  - **效率不高**：标记和清除的执行效率会随着对象数量的增长而降低。
  - 在进行GC的时候，需要**STW**（Stop the world），导致用户体验差。
  - **内存空间的碎片化问题**：标记、清除之后会产生大量的不连续的空间碎片，需要维护一个空闲列表。

> ps: 何为清除？
> 这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表中，下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放。

#### 标记-复制算法（Copying）
为了解决标记-清除算法面对大量可回收对象时执行效率低的问题。
##### 核心思想
将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，在垃圾回收时将正在使用内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。

![JVM标记-复制算法](http://image.yzqfrist.com/20210103112043.png)
##### 优缺点
优点：
- 没有标记和清除过程，实现简单，运行高效。

- 赋值过去后保证空间的连续性，不会出现碎片问题。

- 很适合垃圾对象很多，存活对象很少的场景。

  缺点：

- 将可用内存缩小为原来的一半。

#### 标记-整理算法（Mark-Compact）
复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，此算法并不适合。
##### 核心思想
第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象。
第二阶段将所有的存活对象压缩到内存的一端 ，按顺序排放。之后，清理边界外所有的空间。

![JVM标记-整理算法](http://image.yzqfrist.com/20210103112049.png)
##### 优缺点
优点：
- 消除了标记-清除算法中内存区域分散的缺点。
- 消除了复制算法中内存减半的高额代价。
缺点：
- 从效率来说，标记整理算法要低于复制算法。
- 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。
- 移动过程过程需要STW。
#### 小结
|          | Mark-Sweep         | Copying            | Mark-Compact     |
| -------- | ------------------ | ------------------ | ---------------- |
| 速度     | 中等               | 最快               | 最慢             |
| 空间开销 | 少（但会堆积碎片） | 最大（不堆积碎片） | 少（不堆积碎片） |
| 移动对象 | 否                 | 是                 | 是               |

分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。

在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。
- 年轻代（Young Gen）
年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。
这种情况赋值的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适合于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。
- 老年代（Tenured Gen）
  老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。
  这种情况存在大量的存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。
    - mark阶段的开销与存活对象的数量成正比。
    - sweep阶段的开销与所管理区域的大小成正相关。
    - compact阶段的开销与存活对象的数据成正比。
#### 增量收集算法（Incremental  Collecting）
上述现有算法，在垃圾回收过程中，会STW，应用程序所有的线程都会挂起，等待垃圾回收的完成。如果垃圾回收过程过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为此，诞生了增量收集算法。
##### 核心思想
如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。
增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。
##### 缺点
会有线程切换和上下文转换的消耗 ，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。

### 垃圾回收器
#### 7款经典经典垃圾收集器
- 串行回收器：Serial、Serial Old
- 并行回收器：ParNew、Parallel Scavenge、Parallel Old
- 并发回收器：CMS、G1

![7款垃圾收集器与垃圾分代之间的关系](http://image.yzqfrist.com/20210104212908.png)

- 新生代收集器：Serial、ParNew、Parallel Scavenge
- 老年代收集器：Serial Old、Parallel Old、CMS
- 整堆收集器：G1

#### Serial收集器：串行回收
- Serial收集器是HotSpot在client模式下的默认新生代垃圾收集器
- Serial收集器采用复制算法、串行回收和“Stop-the-World"机制的方式执行内存回收
- 除了年轻代之外，Serial收集器还提供了用于执行老年代垃圾收集的Serial Old收集器。Serial Old收集器同样采用了串行回收和“Stop-the-World”机制，不过内存回收算法使用的是标记-压缩算法。
    - Serial Old是运行在Client模式下默认的老年代垃圾收集器
    - Serial Old在Server模式下主要有两个用途：① 与新生代Parallel Scavenge 配合使用 ② 作为老年代CMS收集器的后备垃圾收集方案

![Serial_Serial Old收集器运行示意图](http://image.yzqfrist.com/20210105193731.png)

这个收集器是一个单线程工作的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调它**在进行垃圾收集时，必须暂停其他所有工作线程，即Stop the World**，直到它收集结束。

优势：简单而高效，内存消耗小。
> **-XX:+UseSerialGC** 指定年轻代和老年代使用串行收集器（新生代Serial GC ，老年代Serial Old  GC）
#### ParNew收集器：并行回收
ParNew：Par --> Parallel  ; New--> 只能处理新生代。
ParNew是Serial 的多线程并行版本。除了采用多线程进行垃圾收集外，其余行为和Serial没有差别。ParNew新生代同样采用复制算法、“Stop-the-World”机制。

![ParNew_Serial Old 收集器运行示意图](http://image.yzqfrist.com/20210105200239.png)
- 对于新生代，回收次数频繁，使用并行方式高效。
- 对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程上下文，串行可以省去切换线程的资源）
- 除了Serial收集器外，目前只有ParNew能与CMS收集器配合工作。
> **-XX:+UserParNewGC** 指定使用ParNew收集器执行内存回收任务，它表示年轻代使用并行收集器，不影响老年代
> **-XX:ParallelGCThreads** 限制垃圾收集器的线程数，默认开启的收集线程数与处理器核心数量相同

#### Parallel Scavenge收集器：吞吐量优先
 Parallel Scavenge也是一款新生代收集器，同样是基于标记-复制算法、并行回收和“Stop-the-World”机制。
 > 吞吐量：运行用户代码时间 / (运行用户代码时间 + 运行垃圾收集时间）
 > 高吞吐量可以有效利用系统资源，主要适合在后台运算而不需要太多交互的分析任务。
 - Parallel Scavenge的目标是达到一个可控制的吞吐量（Throughput）。
 - 有自适应调节策略（GC Ergonomics）

![Parallel Scavenge _ Parallel Old收集器运行示意图](http://image.yzqfrist.com/20210105211114.png)

> **-XX:+UseParallelGC** : 手动指定年轻代使用Parallel并行收集器执行内存回收任务。
> **-XX:+UserParallelOldGC**：手动指定老年代使用Parallel Old使用并行回收收集器。
> 上两个参数，分别适用于新生代和老年代，默认jdk8是开启的。两个参数默认开启一个，另一个也会被开启（互相激活）。
> **-XX:ParallelGCThreads**：设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。
>  - 在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量。
>  - 当CPU数量大于8个，ParallelGCThreads的值等于 3 +((5 * CPU_Count) / 8)
>
> **-XX:MaxGCPauseMillis** : 控制最大垃圾收集停顿时间(STW时间），收集器尽量保证内存回收花费的时间不超过用户设定值。（谨慎使用）
> **-XX:GCTimeRatio**：垃圾收集时间占总时间的比例 （= 1 / (N + 1）)。用于衡量吞吐量的大小。
> - 取值范围（0， 100）。默认值99，也就是垃圾回收时间不超过1%。
> - 与MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Ratio参数就容易超过设定的比例。
> **-XX：UseAdaptiveSizePolicy**：设置Parallel Scavenge的自适应调节策略。
> - 开启后，就不需要人工指定新生代大小、Eden和Survivor区的比例、晋升老年代对象大小等细节参数，虚拟机会根据当前系统的运行情况收集性能监控信息、动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。
> - 在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量和停顿时间，让虚拟机自己完成调优工作。

#### CMS收集器：低延迟
CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。
从名字（包含“mark sweep”）上可以看出CMS收集器是基于标记-清除算法的，它的运行过程分为四个步骤：
1）**初始标记**（CMS initial mark）
2）**并发标记**（CMS concurrent mark）
3）**重新标记**（CMS remark）
4）**并发清除**（CMS concurrent sweep）
其中，初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；而重新标记阶段则是为了修正并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记的时间短；最后是并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。
![CMS收集器运行示意图](http://image.yzqfrist.com/20210106195835.png)

##### 优缺点
优点：并发收集、低延迟
缺点：
1）会产生**内存碎片**，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full  GC。
2） CMS收集器对**CPU资源非常敏感**。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。
3）CMS收集器无法处理浮动垃圾。可能出现“Concurrent Mode Failure”并发失败而导致另一次Full GC产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并**发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有及时回收**，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。

> **-XX:+UseConcMarkSweepGC** 手动指定使用CMS收集器执行内存回收任务。（开启后会自动将-XX：+UseParNewGC打开。即：ParNew（Young区用）+CMS（Old区用）+ Serial Old的组合）
> **-XX：CMSInitiatingOccupanyFraction** 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。（JDK6及以上默认值为92%，如果内存增长缓慢，可以设置一个较大的值，可以有效降低CMS触发频率，可以有效降低Full GC的执行次数）
> **-XX：+UserCMSCompactAtFullCollection**：用于指定在执行完Full GC后对内存空间进行压缩整理，以避免内存碎片的产生（JDK9开始废弃）。
> **-XX：CNSFullGCsBeforeCompaction**：设置执行多少次Full GC后对内存空间进行压缩整理。（JDK9开始废弃）
> **-XX：ParallelCMSThreads**：设置CMS线程数量，默认启动线程数是（ParallelGCThreads + 3）/ 4


> JDK 14 CMS 收集器已被移除

#### G1收集器：区域化分代
- G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续）。使用不同的Regin来表示Eden区、Survivor0区、Survivor1区，老年代等，并将Region作为单次回收的最小单元，即**每次收集到的内存空间都是Region大小的整数倍**，**Region之间是复制算法 ，但整体实际上看作是标记-压缩（Mark-Conpact）算法**。
- 可预测的停顿时间模型，支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集的时间大概率不超过N毫秒。G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，**每次根据允许的收集时间，优先回收价值最大的Region**。
- 由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以叫：垃圾优先（Garbage First）。
- 面向堆内存任何部分来组成回收集（Collection Set， CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed  GC模式。

G1是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的服务器，以极高概率满足GC停顿时间的同时，还就兼具高吞吐量的性能特征。
> G1是JDK9后默认垃圾回收器。 JDK8中开启的话： **-XX：+UseG1GC**

![G1收集器Region分区示意图](http://image.yzqfrist.com/20210110155451.png)

Region中有一类特殊的Humongous区域，专门用来存储大对象。G1 认为只要大小超过一个Region容量一半的对象即可判定为大对象。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region中，G1的大多数行为都把Humongous Region 作为老年代的一部分来进行看待。


> **-XX:G1HeapRegionSize**:设定Region的大小，取值范围为1MB-32MB，且因为2的N次幂。默认值为堆内存的1/2000。
> **-XX：MaxGCPauseMillis**：设置期望达到的最大GC停顿时间（JVM会尽力达到，但不保证达到）。默认值200ms
> **-XX：ParallelGCThread**： 设置STW工作线程数的值，最多设置为8
> **-XX:ConcGCThreads**：设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThread）的1/4 左右
> **-XX：InitatingHeapOccupancyPercent**:设置触发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。

> G1为每一个Region 设计了两个名为**TAMS**（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认在这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围。

##### G1收集器的运行过程
- **初始标记**（Initial Marking）：仅仅只是表示一下GC Roots 能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。
- **并发标记**（Concurrent Marking）：从GC Roots开始对堆中的对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理STAB（原始快照）记录下的在并发时有引用变动的对象。
- **最终标记**（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的STAB记录。
- **筛选回收**（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象赋值到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。


![G1 收集器回收示意图](http://image.yzqfrist.com/20210110162707.png)

#### 其他细节
1、G1使用记忆集避免全堆作为GC Roots扫描来解决跨Region引用对象的问题。G1 的记忆集在存储结构的本质上一种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号。
2、在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？CMS收集器采用增量更新算法实现，而G1收集器则是通过原始快照(STAB)算法来实现。G1为每一个Region 设计了两个名为**TAMS**（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认在这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围。

#### 经典垃圾收集器总结

![经典垃圾收集器总结](http://image.yzqfrist.com/img/20210211091825.png)


### 低延迟垃圾收集器、
目标：**在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟**。
#### Shenandoah收集器（OpenJDK12）
Shenandoah收集器与G1相比：
**相同点**： 都是使用基于Region的堆内存布局，同样有着用于存放大对象的Humongous Region，默认的回收策略也是同样是优先处理回收价值最大的Region。
**不同点**：
1） 支持并发的整理算法，G1的回收阶段是可以多线程并行的，但不能与用户线程并发
2）Shenandoah（目前）是默认不使用分代收集的，换言之，不会有专门的新生代Region或者老年代Region的存在，没有实现分代
3）Shenandoah摒弃了G1中耗费大量内存和计算资源去维护的记忆集，改用名为“连接矩阵”（Connection Matrix）的全局数据结构来记录跨Region的引用关系，降低了处理跨代指针时的记忆集的维护消耗，也降低了伪共享问题的发生概率。
![Shenandoah收集器的链接矩阵示意图](http://image.yzqfrist.com/20210111203202.png)

##### 工作过程
- **初始标记**（Initial Marking）：与G1一样，首先标记与GC Roots直接关联的对象，这个阶段仍是“Stop The World”的，但停顿时间与堆大小无关，只与GC Roots的数量相关。
- <span style="color:red">**并发标记**</span>（Concurrent Marking）：与G1一样，遍历对象图，标记处全部可达的对象，这个阶段是与用户线程一起并发的，时间长短取决于堆中存活对象的数量以及对象图的结构复杂程度。
- **最终标记**（Final Marking）：与G1一样，处理剩余的STAB扫描，并在这个阶段统计出回收价值最高的Region，将这些Region构成一组回收集（Collection Set）。最终标记阶段也会有一小段短暂的停顿。
- **并发清理**（Concurrent Cleanup）：这个阶段用于清理那些整个区域连一个存活对象都没有找到的Region（这类Region被称为Immediate Garbage Region）
- <span style="color:red">**并发回收**</span>（Concurrent Evacuation）：并发回收阶段是Shenandoah与其他HotSpot中的其他收集器的核心差异。在这个阶段，Shenandoah要把回收集里面的存活对象先复制一份到其他未被使用的Region之中。**复制对象和用户线程并发，Shenandoah通过<span style="color:red">读屏障</span>和被称为“Brooks Pointers”的<span style="color:red">转发指针</span>来解决移动对象时，用户线程仍然可能不停对移动的对象进行读写访问的问题。**并发回收阶段运行的时间长短取决于回收集的大小。
- **初始引用更新**（Initial Update Reference）：并发回收阶段复制对象结束后，还需要把堆中所有指向旧对象的引用修正到复制后的新地址，这个操作称为引用更新。初始引用更新的时间很短，会产生一个非常短暂的停顿。
- <span style="color:red">**并发引用更新**</span>（Concurrent Update Reference）：真正开始进行引用更新操作，这个操作是与用户线程一起并发的，时间长短取决于内存中涉及的引用数量的多少。并发引用更新和并发标记不同，它不再需要沿着对象图来搜索，只需要按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值即可。
- **最终引用更新**（Final Update Reference）：解决了堆中的引用更新后，还要修正存在于GC Roots中的引用。这个阶段是Shenandoah的最后一次停顿，停顿时间只与GC Roots 的数量相关。
- **并发清理**（Concu Cleanup）：经过并发回收和引用更新后，整个回收集中所有的Region已再无存活对象。这些Region都变成Immediate Garbage Regions,最后再调用一次并发清理过程来回收这些Region的内存空间，供以后新对象分配使用。

#### ZGC收集器
**ZGC收集器(Z Garbage Collector)是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、  染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器。**

ZGC的Region具有动态性——动态创建和销毁，以及动态的区域容量大小：

- 小型Region（Small Region）：容量固定为2MB，用于存放小于256KB的小对象。
- 中型Region（Medium Region）：容量固定为32MB，用于防止大于等于256KB但小于4MB的对象。
- 大型Region（Large Region）：容量不固定，可以动态变化，但必须是2MB的整数倍，用于存放4MB或以上的大对象，不会被重分配。

![ZGC Region](http://image.yzqfrist.com/ZGC%20Region.png)

##### 染色指针

从前，如果我们要在对象上存储一些额外的、只供收集器或者虚拟机本身使用的数据，通常会在对象头中增加额外的存储字段，如对 象的哈希码、分代年龄、锁记录等就是这样存储的。这种记录方式在有对象访问的场景下是很自然流畅的，不会有什么额外负担。

但如果对象存在被移动过的可能性，即不能保证对象访问能够成功呢？ 又或者有一些根本就不会去访问的对象，但又希望得知该对象的某些信息的应用场景呢？
HotSpot虚拟机的几种收集器有不同的标记实现方案，有的把标记直接记录在 对象头上（如Serial收集器），有的把标记记录在与对象相互独立的数据结构上（如G1、Shenandoah使用了一种相当于堆内存的1/64大小的，称为BitMap的结构来记录标记信息），而ZGC的染色指针是最直接的、最纯粹的，它直接把标记信息记在引用对象的指针上，这时，与其说可达性分析是遍历对象图来标记对象，还不如说是遍历“引用图”来标记“引用”了。

染色指针是一种直接将少量额外的信息存储在指针上的技术，可是为什么指针本身也可以存储额外信息呢？在64位系统中，理论可以访问的内存高达16EB（2的64次幂）字节。实际上，基于需求（用不到那么多内存）、性能（地址越宽在做地址转换时需要的页表级数越多）和成本（消耗更多晶 体管）的考虑，在AMD64架构中只支持到52位（4PB）的地址总线和48位（256TB）的虚拟地址空 间，所以目前64位的硬件实际能够支持的最大内存只有256TB。此外，操作系统一侧也还会施加自己的约束，64位的Linux则分别支持47位（128TB）的进程虚拟地址空间和46位（64TB）的物理地址空 间，64位的Windows系统甚至只支持44位（16TB）的物理地址空间。

尽管Linux下64位指针的高18位不能用来寻址，但剩余的46位指针所能支持的64TB内存在今天仍然能够充分满足大型服务器的需要。鉴于此，ZGC的染色指针技术继续盯上了这剩下的46位指针宽度，将其高4位提取出来存储四个标志信息。通过这些标志位，虚拟机可以直接从指针中看到其引用对象的三色标记状态、是否进入了重分配集（即被移动过）、是否只能通过finalize()方法才能被访问到。当然，由于这些标志位进一步压缩了原本就只有46位的地址空间，也直接导致 ZGC能够管理的内存不可以超过4TB（2的42次幂）



![Colored Pointer](http://image.yzqfrist.com/Colored%20Pointer-1621035397773.jpg)



>  ZGC收集器采用了染色指针技术（Colored Pointer），**是一种直接将少量额外的信息存储到指针上的技术**。

##### 染色指针的三大优势

- 染色指针可以使得**一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉**，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理。使得理论上只要还有一个空闲Region，ZGC就能完成收集，至于为什么染色指针能够导致这样的结果，笔者将在后续解释其“自愈”特性的时候进行解释。

- 染色指针可以**大幅减少**在垃圾收集过程中**内存屏障的使用数量**，设置内存屏障，尤其是写屏障的目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作。实际上，到目前为止ZGC都并未使用任何写屏障，只使用了读屏障（一部分是染色指针的功劳，一部分是ZGC现在还不支持分代收集，天然就没有跨代引用的问题）。能够省去一部分的内存屏障，显然对程序运行效率是大有裨益的，所以ZGC对吞吐量的影响也相对较低。

> 内存屏障（Memory Barrier）的目的是为了指令不因编译优化、CPU执行优化等原因而导致乱序执行，它也是可以细分为仅确保读操作顺序正确性和仅确保写操作顺序正确性的内存屏障的。

- 染色指针可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以 便日后进一步提高性能。现在Linux下的64位指针还有前18位并未使用，它们虽然不能用来寻址，却可以通过其他手段用于信息记录。

### 前置问题

Java虚拟机作为一个普普通通的进程， 这样随意重新定义内存中某些指针的其中几位，操作系统是否支持？处理器是否支持？

Linux/x86-64平台上的ZGC使用了多重映射（Multi-Mapping）将多个不同的虚拟内存地址映射到同一个物理内存地址上，这是一种多对一映射，意味着ZGC在虚拟内存中看到的地址空间要比实际的堆内存容量来得更大。把染色指针中的标志位看作是地址的分段符，那只要将这些不同的地址段都映射到同一个物理内存空间，经过多重映射转换后，就可以使用染色指针正常进行寻址了。
![20200527212952247](http://image.yzqfrist.com/20200527212952247.png)

##### ZGC收集器工作过程

ZGC的运作过程大致可划分为以下四个大的阶段。全部四个阶段都是可以**并发**执行的，仅是两个阶段中间会存在短暂的停顿小阶段，这些小阶段， 譬如初始化GC Root直接关联对象的Mark Start，与之前G1和Shenandoah的Initial Mark阶段并没有什么差异。

![20200527213002856](http://image.yzqfrist.com/20200527213002856.png)

- **并发标记（Concurrent Mark）**：并发标记是遍历对象图做可达性分析的阶段，前后也要经过初始标记、最终标记的短暂停顿，而且这些停顿阶段所做的事情在目标上也是相类似的。ZGC 的标记是在指针上而不是在对象上进行的，标记阶段会更新染色指针中的Marked 0、Marked 1标志位。

- **并发预备重分配（Concurrent Prepare for Relocate）**：这个阶段需要根据特定的**查询条件统计**得出本次收集过程**要清理哪些Region，将这些Region组成重分配集（Relocation Set）**。ZGC划分Region的目的并非为了像G1那样做收益优先的增量回收。ZGC每次回收都会扫描**所有**的Region，用**范围更大的扫描成本**换取省去G1中记忆集的维护成本。因此，ZGC的重分配集只是决定了里面的存活对象会被重新复制到其他的Region中，里面的Region会被释放，而并不能说回收行为就只是针对这个集合里面的Region进行，因为标记过程是针对全堆的。此外，在JDK 12的ZGC中开始支持的类卸载以及弱引用的处理，也是在这个阶段中完成的。

- **并发重分配（Concurrent Relocate）**：**重分配**是ZGC执行过程中的核心阶段，这个过程**要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（Forward Table）**，记录从旧对象到新对象的转向关系。得益于染色指针的支持，ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”（SelfHealing）能力。这样做的好处是只有**第一次访问旧对象会陷入转发**，也就是只慢一次，对比 Shenandoah的Brooks转发指针，那是每次对象访问都必须付出的固定开销，简单地说就是每次都慢， 因此ZGC对用户程序的运行时负载要比Shenandoah来得更低一些。还有另外一个直接的好处是由于染色指针的存在，一旦重分配集中某个Region的存活对象都复制完毕后，这个**Region就可以立即释放用于新对象的分配**（但是转发表还得留着不能释放掉），哪怕堆中还有很多指向这个对象的未更新指针也没有关系，这些旧指针一旦被使用，它们都是可以自愈的。

- **并发重映射（Concurrent Remap）**：重映射所做的就是**修正整个堆中指向重分配集中旧对象的所有引用**，这一点从目标角度看是与Shenandoah并发引用更新阶段一样的，但是ZGC的并发重映射并不是一个必须要“迫切”去完成的任务，因为前面说过，即使是旧引用，它也是可以自愈的，最多只是第一次使用时多一次转发和修正操作。重映射清理这些旧引用的主要目的是为了不变慢（还有清理结束后可以释放转发表这样的附带收益），所以说这并不是很“迫切”。因此，ZGC很巧妙地把**并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成**，反正它们都是要遍历所有对象的，这样合并就节省了一次遍历对象图的开销。一旦所有指针都被修正之后，原来记录新旧对象关系的转发表就可以释放掉了。



##### 相比G1、Shenandoah

相比G1、Shenandoah等先进的垃圾收集器，ZGC在实现细节上做了一些不同的权衡选择，譬如G1 需要通过写屏障来维护记忆集，才能处理跨代指针，得以实现Region的增量回收。记忆集要占用大量的内存空间，写屏障也对正常程序运行造成额外负担，这些都是权衡选择的代价。ZGC就**完全没有使用记忆集**，它甚至**连分代都没有**，连像CMS中那样只记录新生代和老年代间引用的卡表也不需要，因而完全**没有用到写屏障**，所以给用户线程带来的运行负担也要小得多。可是，必定要有优有劣才会称作权衡，ZGC的这种选择也限制了它能承受的**对象分配速率不会太高**。可以想象以下场景来理解 ZGC的这个劣势：ZGC准备要对一个很大的堆做一次完整的并发收集，假设其全过程要持续十分钟以上（切勿混淆并发时间与停顿时间，ZGC立的Flag是停顿时间不超过十毫秒），在这段时间里面，由于应用的对象分配速率很高，将创造大量的新对象，这些新对象很难进入当次收集的标记范围，通常就只能全部当作存活对象来看待——尽管其中绝大部分对象都是朝生夕灭的，这就产生了大量的浮动垃圾。如果这种高速分配持续维持的话，每一次完整的并发收集周期都会很长，回收到的内存空间持续小于期间并发产生的浮动垃圾所占的空间，堆中剩余可腾挪的空间就越来越小了。目前唯一的办法就是尽可能地增加堆容量大小，获得更多喘息的时间。但是若要从根本上提升ZGC能够应对 的对象分配速率，还是需要引入分代收集，让新生对象都在一个专门的区域中创建，然后专门针对这 个区域进行更频繁、更快的收集。

