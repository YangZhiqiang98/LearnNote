### 基本概念

- **文件描述符 (file descriptor)** ：用于表述指向文件的引用的抽象化概念。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。
- **缓存 I/O**：操作系统会将 I/O 的数据缓存在文件系统的页缓存中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中， 然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。

### I/O 交互（read）

![I/O 交互](https://cdn.jsdelivr.net/gh/YangZhiqiang98/ImageBed/1574180-20191128125037162-803835128.png)

上图可分为两个阶段：

1、数据准备阶段：发起 I/O 请求，操作系统将数据从磁盘拷贝到内核缓冲区。

2、内核空间拷贝到进程空间阶段，将数据从内核缓冲区拷贝到进程的地址空间。

#### 阻塞与非阻塞

  描述的是调用方在第一阶段的状态(**准备数据时调用方状态**)。

- 阻塞：调用方发起 I/O 请求后一直阻塞等待，直到被调用数据准备完成。
- 非阻塞：调用方发起 I/O 请求后不管数据是否准备完成立即返回，不一直阻塞，然后采用轮询或其他方式获取结果。

#### 同步和异步

  描述的是在第二阶段被调用方的状态(**数据准备完成后被调用方状态**)。

- 同步：被调用方一直等待数据从内核缓冲区拷贝到程序地址空间后才会返回结果给调用方。
- 异步：被调用方先返回结果给调用方，等待数据从内核缓冲区拷贝到程序地址空间后再通过回调函数或产生某个信息来通知调用方。

### Linux 下的五种 I/O 模型

#### 1.同步阻塞IO（blocking I/O）

 进程发起I/O请求后会一直阻塞等待，直到数据拷贝到进程地址空间。进程在一、二阶段都处于阻塞状态。

![block io](https://cdn.jsdelivr.net/gh/YangZhiqiang98/ImageBed/block%20%20io.png)

上图中，应用进程通过系统调用 recvfrom 接收数据，但由于内核还未准备好数据报，应用进程就阻塞住了。直到内核准备好数据报，recvfrom 完成数据报复制工作，应用进程才能结束阻塞状态。

举例：A拿着一支鱼竿在河边钓鱼，并且一直在鱼竿前等，在等的时候不做其他的事情，十分专心。只有鱼上钩的时，才结束掉等的动作，把鱼钓上来。

#### **2.同步非阻塞IO（noblocking I/O）**

进程发起 I/O 请求后如果数据还未准备成功会先返回进行其他操作，通过轮询的方式定时获取数据准备结果。数据准备成功后阻塞等待，直到数据拷贝到进程地址空间。进程在第二阶段是阻塞状态。

![noblokcing io](https://cdn.jsdelivr.net/gh/YangZhiqiang98/ImageBed/noblocking%20%20io.png)

上图中，应用进程通过 recvfrom 系统调用不停的去和内核交互，直到内核准备好数据报。从上面的流程中可以看出，应用进程进入轮询状态时等同于阻塞，所以非阻塞的 I/O 似乎并没有提高进程工作效率。

举例：B 也在河边钓鱼，但是 B 不想将自己的所有时间都花费在钓鱼上，在等鱼上钩这个时间段中，B 也在做其他的事情（一会看看书，一会读读报纸，一会又去看其他人的钓鱼等），但 B 在做这些事情的时候，每隔一个固定的时间检查鱼是否上钩。一旦检查到有鱼上钩，就停下手中的事情，把鱼钓上来。



#### **3.信号驱动IO（signal blocking I/O）**

进程调用 sigaction 函数注册相应 fd 的信号函数，然后返回结果进程继续执行，等数据准备完成后内核执行信号函数通知进程将数据从内核缓存拷贝到进程地址空间中。由于仍然需要等待数据从内核缓存拷贝到进程地址空间，所以本质是同步非阻塞 I/O 模型，区别在于获取数据准备成功的信号的方式不同(前者轮询)。进程在第二阶段是阻塞状态。


![signal blocking](https://cdn.jsdelivr.net/gh/YangZhiqiang98/ImageBed/signal%20blocking.png)



举例：C 也在河边钓鱼，但与 A、B 不同的是，C 比较聪明，他给鱼竿上挂一个铃铛，当有鱼上钩的时候，这个铃铛就会被碰响，C 就会将鱼钓上来。

#### **4.IO 多路复用（I/O multiplexing）**

I/O 多路复用是指进程可以同时监控多个文件描述符，内核如果准备好其中的数据就会通知相应进程。进程在第二阶段是阻塞状态。

- 进程调用 select 或者 poll 监听指定文件描述符，返回结果进程不会阻塞等待。
- select/poll 会轮询所有监听的文件描述符，如果发现有准备好的数据就将相应的 fd 放进 fd_set 中最后返回这些 fd，并通知进程将这些数据拷贝到进程地址空间。
  

![I/O multiplexing](https://cdn.jsdelivr.net/gh/YangZhiqiang98/ImageBed/IO%20multiplexing.png)

总结：I/O 多路复用模型本质是同步非阻塞 I/O  模型，与同步非阻塞 I/O 模型的区别在于 I/O 多路复用可以实现一个进程或线程同时监控多个 socket，适用于高并发。

举例：D 同样也在河边钓鱼，但是 D 生活水平比较好，D 拿了很多的鱼竿，一次性有很多鱼竿在等，D 不断的查看每个鱼竿是否有鱼上钩。增加了效率，减少了等待的时间。

#### **5.异步IO（asynchronous I/O）**

进程调用 aio_read 通知内核准备数据，并将准备好的数据拷贝到指定进程地址空间中，最后执行指定的函数或产生一个信号通知进程。该种模型在第一、二阶段均没有阻塞，所以是异步非阻塞。

![asynchronous](https://cdn.jsdelivr.net/gh/YangZhiqiang98/ImageBed/asynchronous.png)

举例：E 也想钓鱼，但 E 有事情，于是他雇来了 F，让 F 帮他等待鱼上钩，一旦有鱼上钩，F 就打电话给 E，E 就会将鱼钓上去。



#### 总结

阻塞 IO 模型、非阻塞 IO 模型、IO 复用模型 (select/poll/epoll)、信号驱动 IO 模型都属于同步 IO，因为阶段 2 是阻塞的。

阻塞程度：阻塞IO>非阻塞IO>多路转接IO>信号驱动IO>异步IO，效率是由低到高的。

![总结](https://cdn.jsdelivr.net/gh/YangZhiqiang98/ImageBed/sumer.png)

### 多路复用的实现方式：***select、poll、epoll***

1、支持一个进程所能打开的最大连接数

| select | 单个进程所能打开的最大连接数有 FD_SETSIZE 宏定义（FD_SETSIZE 的值在 linux 下一般被定义为 1024，意思是 select 管理的描述符的最大值不能大于 1024（1024 也不行）），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。 |
| ------ | ------------------------------------------------------------ |
| poll   | poll 本质上和 select 没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的 |
| epoll  | 虽然连接数有上限，但是很大，1G 内存的机器上可以打开 10 万左右的连接，2G 内存的机器可以打开 20 万左右的连接 |

2、FD 剧增后带来的 IO 效率问题

| select | 因为每次调用时都会对连接进行线性遍历，所以随着 FD 的增加会造成遍历速度慢的“线性下降性能问题”。 |
| ------ | ------------------------------------------------------------ |
| poll   | 同上                                                         |
| epoll  | 因为 epoll 内核中实现是根据每个 fd 上的 callback 函数来实现的，只有活跃的 socket 才会主动调用 callback，所以在活跃 socket 较少的情况下，使用 epoll 没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。 |

3、 消息传递方式

| select | 内核需要将消息传递到用户空间，都需要内核拷贝动作 |
| ------ | ------------------------------------------------ |
| poll   | 同上                                             |
| epoll  | epoll 通过内核和用户空间共享一块内存来实现的。   |

**总结**

综上，在选择 select，poll，epoll 时要根据具体的使用场合以及这三种方式的自身特点。

1、表面上看 epoll 的性能最好，但是在连接数少并且连接都十分活跃的情况下，select 和 poll 的性能可能比 epoll 好，毕竟 epoll 的通知机制需要很多函数回调。

2、select 低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善



### 参考

[1] [五种常用I/O模型](https://blog.csdn.net/hongxiancheng/article/details/107025083)

[2] [图文全解IO模型](http://www.gameboys.cn/article/52)

[3] [【精辟】socket阻塞与非阻塞，同步与异步，select，pool，epool](https://blog.csdn.net/zhang2531/article/details/52143562)

[4] [IO概念和五种IO模型](https://www.cnblogs.com/shengguorui/p/11949282.html)

[5] [100%弄明白5种IO模型](https://zhuanlan.zhihu.com/p/115912936)

[6] [这次答应我，一举拿下 I/O 多路复用！ (qq.com)](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247489558&idx=1&sn=7a96604032d28b8843ca89cb8c129154&scene=21#wechat_redirect)