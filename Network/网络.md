#### TCP四元组

TCP四元组可以唯一的确定一个连接，包括：源地址、源端口、目的地址、目的端口。

源地址和目的地址的字段（32位）是在IP头部中，作用是通过**IP协议发送报文给对方主机**。

源端口和目的端口（16位）是在TCP头部中，作用是告知**TCP协议应该把报文发送给哪个进程**。

##### TCP和UDP区别

1、连接

- TCP是面向连接的传输层协议,传输数据前先要建立连接。
- UDP不要连接,即刻传输数据。

2、服务对象

- TCP是一对一的两点服务,即一条连接只有两个端点。
- UDP支持-对一、一对多、多对多的交互通信

3、可靠性

- TCP可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。
- UDP尽最大努力交付,不保证可靠交付数据。

4、拥塞控制、流量控制

- TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
- UDP 则没有，即使网络非常拥堵了,也不会影响UDP的发送速率。

5、首部开销

- TCP首部长度较长，会有一定的开销，首部在没有使用「选项」 段时是20个字节，如果使用了[选项]字段则会变长的。
- UDP首部只有8个字节,且是固定不变的，开销较小

6、传输方式

- TCP是流式传输，没有边界，但保证顺序和可靠.
- UDP是一个包一个包的发送，是有边界的，可能会丢包和乱序.

7、分片不同

- TCP的数据大小如果大于**MSS**(最大报文段长度)大小,则会在传输层进行分片，目标主机收到后，也同样在传输层组装TCP数据包，如果中途丢失了一个分片,只需要传输丢失的这个分片。
- UDP的数据大小如果大于**MTU**(最大传输单元)大小，则会在IP层进行分片，目标主机收到后，在IP层组装完数据，接着再传给传输层，但是如果中途丢了一个分片，则就需要重传所有的数据包，这样传输效率非常差，所以通常UDP的报文应该小于MTU。

##### TCP和UDP的应用场景

TCP：FTP文件传输、HTTP/HTTPS

UDP

- 包总量较少的通信，如DNS
- 视频、音频等多媒体通信
- 广播通信

#### TCP连接建立

[三次握手示意图](https://www.processon.com/view/link/6044bf27f346fb26cf43c8b6)

过程：

- 一开始，客户端和服务端都处于`CLOSED`状态，先是服务端主动监听某个端口，处于`LISTEN`状态。

- 客户端会随机初始化序号（client_isn),将此序号置于TCP序号字段中，同时把`SYN `标志位置为1，表示SYN报文。接着把第一个SYN报文发送给服务端，表示向服务端发起连接，该报文**不包含应用层数据**，之后客户端处于`SYN-SENT `状态。
- 服务端收到客户端的SYN报文后，首先服务端也随机初始化自己的序号（server-isn），将此序号填入TCP首部的序号字段中，其次把TCP首部的确认应答号字段填入`client_isn + 1`，接着把`SYN`和`ACK`标志位置为1，最后把该报文发送给客户端，该报文也**不包含应用层数据**，之后服务端处于`SYN-RCVD`状态。
- 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文TCP首部`ACK `标志位置为1，其次确认应答号填入`server_isn + 1`，最后把该报文发送给服务端，这次**可以携带客户到服务器的数据**，之后客户端处于`ESTABLISHED`状态。
- 服务端收到客户端的应答报文后，也进入`ESTABLISHED`状态。



##### 为什是三次握手？

**TCP连接**：用于保证可靠性和流量控制维护的某些信息，这些信息的组合，包括**Socket、序列号和窗口大小**。

1. **防止旧的重复连接初始化造成混乱（主要原因）**
2. **同步双方初始序列号，序列号能够保证数据包不重复、不丢弃和按序传输。**
3. **避免资源浪费**

###### 原因一、防止旧的重复连接初始化造成混乱。

客户端连续发送多次 SYN 建立连接的报文，在网络拥堵情况下：

- 一个「旧 SYN 报文」比「最新的 SYN 」报文早到达了服务端；
- 那么此时服务端就会回一个`SYN + ACK`报文给客户端；
- 客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送`RST`报文给服务端，表示中止这一次连接。

如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：

- 如果是历史连接（序列号过期或超时），则第三次握手发送的报文是RST报文，以此中止历史连接；
- 如果不是历史连接，则第三次发送的报文是ACK报文，通信双方就会成功建立连接；

所以，TCP 使用三次握手建立连接的最主要原因是**防止历史连接初始化了连接**。



###### 原因二、同步双方初始序列号

TCP 协议的通信双方，都必须维护一个「序列号」，序列号是可靠传输的一个关键因素，它的作用：

- 接收方可以去除重复的数据
- 接收方可以根据数据包的序列号按序接收；
- 可以标识发送出去的数据包中，哪些是已经被对方收到的；

可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的`SYN`报文的时候，需要服务端回一个`ACK`应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样**一来一回，才能确保双方的初始序列号能被可靠的同步**。



四次握手其实也能够可靠的同步双方的初始化序号，但由于**第二步和第三步可以优化成一步，**所以就成了「三次握手」。而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。

###### 原因三：避免资源浪费

如果只有「两次握手」，当客户端的`SYN`请求连接在网络中阻塞，客户端没有接收到`ACK`报文，就会重新发送`SYN`，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的`ACK`确认信号，所以每收到一个`SYN`就只能先主动建立一个连接，这会造成什么情况呢？

如果客户端的`SYN`阻塞了，重复发送多次`SYN`报文，那么服务器在收到请求后就会**建立多个冗余的无效链接，造成不必要的资源浪费**。

即两次握手会造成消息滞留情况下，服务器重复接受无用的连接请求SYN报文，而造成重复分配资源。

###### 不使用「两次握手」和「四次握手」的原因：

- 「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；

- 「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数



##### 什么是 SYN 攻击？如何避免 SYN 攻击？

SYN 攻击

 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 `IP 地址的`SYN报文，服务端每接收到一个`SYN`报文，就进入`SYN_RCVD`状态，但服务端发送出去的`ACK + SYN`报文，无法得到未知 IP 主机的ACK应答，久而久之就会**占满服务端的 SYN 接收队列（未连接队列）**，使得服务器不能为正常用户服务。

防范SYN攻击措施：降低主机的等待时间使主机尽快的释放半连接的占用，短时间受到某IP的重复SYN则丢弃后续请求。

SYN COOKie

#### TCP连接断开

[四次挥手示意图](https://www.processon.com/view/link/604603637d9c082c92e1c771)

- 客户端打算关闭连接，此时会发送一个 TCP 首部`FIN`标志位被置为1的报文，也即FIN报文，之后客户端进入`FIN_WAIT_1`状态。
- 服务端收到该报文后，就向客户端发送`ACK`应答报文，接着服务端进入`CLOSED_WAIT`状态。

- 客户端收到服务端的ACK应答报文后，之后进入FIN_WAIT_2状态。
- 等待服务端处理完数据后，也向客户端发送FIN报文，之后服务端进入LAST_ACK状态。
- 客户端收到服务端的FIN报文后，回一个ACK应答报文，之后进入TIME_WAIT状态
- 服务器收到了ACK应答报文后，就进入了CLOSED状态，至此服务端已经完成连接的关闭。
- 客户端在经过2MSL一段时间后，自动进入CLOSED状态，至此客户端也完成连接的关闭.

**主动关闭连接的，才有 TIME_WAIT 状态。**

##### 为什么要四次挥手？

- 关闭连接时，客户端向服务端发送FIN时，仅仅表示客户端不再发送数据了但是还能接收数据。
- 服务器收到客户端的FIN报文时，先回一个ACK应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送FIN报文给客户端来表示同意现在关闭连接。

服务端通常需要等待完成数据的发送和处理，所以服务端的ACK和FIN一般都会分开发送，从而比三次握手导致多了一次。

##### 为什么 TIME_WAIT 等待的时间是 2MSL?

> MSL是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个TTL字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。

MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以MSL 应该要大于等于 TTL消耗为 0 的时间，以确保报文已被自然消亡.

2MSL的时间是从客户端接收到 FIN 后发送 ACK 开始计时的。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么2MSL 时间将重新计时。

一、保证TCP协议的全双工连接能够可靠关闭

二、保证这次连接的重复数据段从网络中消失

·    1）这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，B超时重传FIN+ACK报文段，而A能在2MSL时间内收到这个重传的FIN+ACK报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到CLOSED状态，若**A在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B*重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则B无法正常进入到CLOSED状态

·    2）A在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。



##### 为什么需要 TIME_WAIT 状态？

主动发起关闭连接的一方，才会有TIME-WAIT状态。

需要 TIME-WAIT 状态，主要是两个原因：

- 防止具有相同「四元组」的「旧」数据包被收到；
- 保证「被动关闭连接」的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭；

#### Socket编程

[Socket编程](https://www.processon.com/view/link/60460e98e0b34d07b863ddfb)

[三次握手与Socket](https://www.processon.com/view/link/60460f2707912947636b6d68)

客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后



[四次挥手与Socket](https://www.processon.com/view/link/60460f3d1e08531bf8d12175)

#### 重传机制

常见的重传机制

- 超时重传
- 快速重传
- SACK
- D-SACK

##### 超时重传

超时重传：在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的`ACK `确认应答报文，就会重发该数据。

TCP 在以下两种情况下回发生超时重传：

- 数据包丢失
- 确认应答丢失



###### 超时时间应该设置为多少呢？

>  RTT(Round-Trip Time 往返时延):就是数据从网络一端得到另一端所需的时间，也就是包的往返时间。
>
> RTO（Retransmission Timeout 超时重传时间）

- 当超时时间RTO较大时，重发就慢，网络的空隙时间增大，降低了网络传输效率。
- 当超时时间RTO较小时，会导致不必要的重传，会导致网络负荷增大，导致网络阻塞，导致更多的重发。

所以，**超时重传时间RTO的值应该略大于报文往返RTT的值。**这两个值是动态变化的。

如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP的策略是**超时间隔加倍**。

也就是**每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值额两倍。两次超时，就说明网络环境差，不宜频繁反复发送**。

超时触发重传存在的的问题是，超时周期可能相对较长。于是可以用[快速重传]机制来解决超时重传的时间等待。

##### 快速重传

**TCP的快速重传机制，不以时间为驱动，而是以数据驱动重传。**

[快速重传](https://www.processon.com/view/link/6046b0995653bb620cdd93d5)

当收到三个相同的ACK 报文时，会在定时器过期之前，重传丢失的报文段。

快速重传机制只解决了一个问题，就是超时时间的问题，但是它还面临另外一个问题，就是**重传的时候。是重传之前的一个，还是重传所有的问题**。

为了解决不知道该重传哪些TCP报文，于是就有了`SACK `方法。

##### SCAK方法

> SACK（ Selective Acknowledgment 选择性确认)

[SACK示意图](https://www.processon.com/view/link/6046b7e47d9c082c92e287e0)

这种方式需要在 TCP 头部「选项」字段里加一个`SACK`的东西，它可以将**缓存的地图发送给发送方**，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以**只重传丢失的数据**。

##### Duplicate SACK

Duplicate SACK 又称D-SACK，其主要**使用了 SACK 来告诉「发送方」有哪些数据被重复接收了**。

D-SACK有这么几个好处：

1. **可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;**
2.  **可以知道是不是「发送方」的数据包被网络延迟了**;
3. 可以知道网络中是不是把「发送方」的数据包给复制了

#### 滑动窗口

TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了，再发送下一个。这样的传输方式有一个缺点：**数据包的往返时间越长，通信的效率就越低。**为解决这个问题，TCP 引入了**窗口**这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。

那么有了窗口，就可以指定窗口大小，窗口大小就是指**无需等待确认应答，而可以继续发送数据的最大值**。

窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。

##### 窗口大小由哪一方决定?

TCP 头里有一个字段叫`Window`,也就是窗口大小。

这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。

所以，通常窗口的大小是由接收方的窗口大小来决定的

[发送方的滑动窗口示意图](https://www.processon.com/view/link/60478544f346fb26cf4acb1b)

[接收方滑动窗口](https://www.processon.com/view/link/604789577d9c082c92e5dbf8)

接收窗口的大小是**约等于**发送窗口的大小的。

#### 流量控制

TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。

发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的，而操作系统的缓冲区，会被操作系统调整。

##### 那操心系统的缓冲区，是如何影响发送窗口和接收窗口的呢？

- 当应用程序没有及时读取缓存时，可能最后窗口收缩为0，发生窗口关闭现象，
- 如果发生了先减少缓存，再收缩窗口，可能会丢包。为了防止这种情况，**TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况**

##### 窗口关闭

如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。

接收方向发送方通告窗口大小时，是通过ACK报文来通告的。

那么，当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，那会导致发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不采取措施，这种相互等待的过程，会造成了死锁的现象。

###### TCP 是如何解决窗口关闭时，潜在的死锁现象呢？

TCP 为每个连接设有一个**持续定时器**，只要 TCP 连接一方收到对方的**零窗口通知**，就启动持续计时器。

如果持续计时器超时，就会发送**窗口探测 ( Windowprobe ) 报文**，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。

##### 糊涂窗口综合症

如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小。		到最后，**如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症**；

要知道，我们的TCP + IP头有40个字节，为了传输那几个字节的数据，要达上这么大的开销，这太不经济了。

糊涂窗口综合症的现象是可以发生在发送方和接收方：

- 接收方可以通告一个小的窗口
- 而发送方可以发送小数据于是

要解决糊涂窗口综合症，就解决上面两个问题就可以了

- 让接收方不通告小窗口给发送方
- 让发送方避免发送小数据

###### 怎么让接收方不通告小窗口呢？

接收方通常的策略如下:

当「窗口大小」小于 min( MSS，缓存空间/2 ) ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为0，也就阻止了发送方再发数据过来。

等到接收方处理了一些数据后，窗口大小 >= MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来

###### 怎么让发送方避免发送小数据呢？

发送方通常的策略:

使用 Nagle 算法，该算法的思路是延时处理，它满足以下两个条件中的一条才可以发送数据：

- 要等到窗口大小 >= MSS或是数据大小 >= MSS
- 收到之前发送数据的ack回包

只要没满足上面条件中的一条，发送方一直在囤积数据，直到满足上面的发送条件。

另外，Nagle 算法默认是打开的，如果对于一些需要小数据包交互的场景的程序，比如，telnet 或 ssh这样的交互性比较强的程序，则需要关闭 Nagle 算法

#### 拥塞控制

###### 为什么要有拥塞控制呀，不是有流量控制了吗？

前面的流量控制是**避免「发送方」的数据填满「接收方」的缓存**，但是并不知道网络的中发生了什么。

一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。

**在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大....**

所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。

于是，就有了拥塞控制，控制的目的就是**避免「发送方」的数据填满整个网络**。为了在「发送方」调节所要发送数据的量，定义了一个叫做「拥塞窗口」的概念。

###### 什么是拥塞窗口？和发送窗口有什么关系呢？

**拥塞窗口 cwnd是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的。**

发送窗口swnd和接收窗口rwnd是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是**swnd = min(cwnd, rwnd)，**也就是拥塞窗口和接收窗口中的最小值。

拥塞窗口cwnd变化的规则：

- 只要网络中没有出现拥塞，cwnd就会增大；
- 但网络中出现了拥塞，cwnd就减少；

###### 那么怎么知道当前网络是否出现了拥塞呢？

其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是**发生了超时重传，就会认为网络出现了拥塞**。

###### 拥塞控制有哪些控制算法？

拥塞控制主要是四个算法：

- 慢启动
- 拥塞避免
- 拥塞发生
- 快速恢复

##### 慢启动

慢启动的算法记住一个规则就行：**当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1**。

慢启动算法，发包的个数是**指数性的增长**。

有一个叫慢启动门限ssthresh（slow start threshold）状态变量。

- 当cwnd < ssthresh时，使用慢启动算法。
- 当cwnd >= ssthresh时，就会使用「拥塞避免算法」

##### 拥塞避免

当拥塞窗口cwnd「超过」慢启动门限ssthresh就会进入拥塞避免算法。

一般来说ssthresh的大小是65535字节。

那么进入拥塞避免算法后，它的规则是：**每当收到一个 ACK 时，cwnd 增加 1/cwnd**。

[拥塞避免与慢启动](https://www.processon.com/view/link/60480002f346fb26cf4b0b4f)

拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。

就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。

当触发了重传机制，也就进入了「拥塞发生算法」。

##### 拥塞发生

当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：

- 超时重传
- 快速重传

###### 发生超时重传的拥塞发生算法

当发生了「超时重传」，则就会使用拥塞发生算法。

这个时候，ssthresh 和 cwnd 的值会发生变化：

- ssthresh设为cwnd/2，

- cwnd重置为1

接着，就重新开始慢启动，慢启动是会突然减少数据流的。这真是一旦「超时重传」，马上回到解放前。但是这种方式太激进了，反应也很强烈，会造成网络卡顿。

###### 发生快速重传的拥塞发生算法

当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。

TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则ssthresh和cwnd变化如下：

- cwnd = cwnd/2，也就是设置为原来的一半;
- ssthresh = cwnd;

- 进入快速恢复算法

##### 快速恢复

快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，

正如前面所说，进入快速恢复之前，cwnd和ssthresh已被更新了：

- cwnd = cwnd/2，也就是设置为原来的一半;
- ssthresh = cwnd;

然后，进入快速恢复算法如下：

- 拥塞窗口cwnd = ssthresh + 3（ 3 的意思是确认有 3 个数据包被收到了）；
- 重传丢失的数据包；
- 如果再收到重复的 ACK，那么 cwnd 增加 1；
- 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；

[快恢复](https://www.processon.com/view/link/604801f57d9c082c92e61466)

**上面这个算法也有问题，那就是——它依赖于3个重复的Acks**。注意，3个重复的Acks并不代表只丢了一个数据包，很有可能是丢了好多包。但这个算法只会重传一个，而剩下的那些包只能等到RTO超时，于是，进入了恶梦模式——超时一个窗口就减半一下，多个超时会超成TCP的传输速度呈级数下降，而且也不会触发Fast Recovery算法了。

#### TCP 延迟确认与 Nagle 算法

当我们 TCP 报文的承载的数据非常小的时候，例如几个字节，那么整个网络的效率是很低的，因为每个 TCP 报文中都会有 20 个字节的 TCP 头部，也会有 20 个字节的 IP 头部，而数据只有几个字节，所以在整个报文中有效数据占有的比重就会非常低。

那么就出现了常见的两种策略，来减少小报文的传输，分别是：

- Nagle 算法
- 延迟确认

##### Nagle 算法是如何避免大量 TCP 小数据报文的传输？

Nagle 算法做了一些策略来避免过多的小数据报文发送，这可提高传输效率。

Nagle 算法的策略：

- 没有已发送未确认报文时，立刻发送数据。
- 存在未确认报文时，直到「没有已发送未确认报文」或「数据长度达到 MSS 大小」时，再发送数据。

只要没满足上面条件中的一条，发送方一直在囤积数据，直到满足上面的发送条件

Nagle 算法一定会有一个小报文，也就是在最开始的时候

##### 延迟确认

事实上当没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头和 TCP头，但却没有携带数据报文。

为了解决 ACK 传输效率低问题，所以就衍生出了TCP 延迟确认。

TCP 延迟确认的策略：

- 当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方
- 当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送
- 如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK

#### 什么是 TCP 半连接队列和全连接队列？

在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：

- 半连接队列，也称 SYN 队列；
- 全连接队列，也称 accepet 队列；

服务端收到客户端发起的 SYN 请求后，内核会把该连接存储到半连接队列，并向客户端响应SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。

[TCP 半连接队列和全连接队列](https://www.processon.com/view/link/6048054a07912947636f7982)



[SYN Cookie](https://www.processon.com/view/link/6048b2306376893db7d79748)

