

Redis 实现高可用有三种部署模式：**主从模式，哨兵模式，集群模式**。

### 主从模式

主服务器负责接收写请求，从服务器负责接收读请求，从服务器的数据由主服务器复制过去。主从服务器的数据是已知的。读写分离，保证高可用。

![主从架构](https://cdn.jsdelivr.net/gh/YangZhiqiang98/ImageBed/20211027063857.png)

### 复制功能

主从架构的特点之一：主服务器和从服务器的数据是一致的。

#### 复制功能的具体实现

复制功能分为两个操作：

- 同步（sync)
  - 将从服务器的数据库状态更新至主服务器的数据库状态
- 命令传播（command propagate）
  - 主服务器的数据库状态被修改，导致主从服务器的数据库状态不一致，让主从服务器的数据库状态重新回到一致状态。

从服务器对主服务器的同步又可以分为两种情况：

- 初次同步：从服务器没有复制过任何的主服务器，或者从服务器要复制的主服务器跟上次服务的主服务器不一样。
- 断线后同步：处于命令传播阶段的主从服务器因为网络原因中断了复制，从服务器通过自动重连重新连接主服务器，并继续复制主服务器。（2.8 版本 sync 命令，2.8之后 psync）

> sync 命令会把所有的数据再次同步，而不是只同步丢失的数据
>
> psync 命令具有**完整重同步和部分重同步**两种模式。

#### 完整重同步

- 一般当 slave 第一次启动连接 master，或者认为是第一次连接，就采用**全量复制**
- 从服务器向主服务器发送 PSYNC 命令
- 收到 PSYNC 命令的主服务器执行 BGSAVE 命令，在后台**生成一个 RDB 文件**。并用一个**缓冲区**来记录从现在开始执行的所有**写命令**。
- 当主服务器的 BGSAVE 命令执行完后，将生成的 RDB 文件发送给从服务器，**从服务器接收和载入 RBD 文件**。将自己的数据库状态更新至与主服务器执行 BGSAVE 命令时的状态。
- 主服务器将所有缓冲区的**写命令发送给从服务器**，从服务器执行这些写命令，达到数据最终一致性。

![全量复制流程](https://cdn.jsdelivr.net/gh/YangZhiqiang98/ImageBed/20211101202606.png)

#### 部分重同步（增量复制）

slave 与 master 全量同步之后，master 上的数据，如果再次发生更新，就会触发**增量复制**。部分重同步可以让我们断线后重连**只需要同步缺失的数据**。

部分重同步功能由以下部分组成：

- 主从服务器的**复制偏移量**
- 主服务器的**复制积压缓冲区**
- 服务器运行的 ID(**run ID**)

通过**对比主从复制的偏移量**，就很容易知道主从服务器的数据是否处于一致性的状态！

那断线重连以后，从服务器向主服务器发送 PSYNC 命令，报告现在的偏移量是 36，那么主服务器该对从服务器执行完整重同步还是部分重同步呢？这就交由**复制积压缓冲区**来决定。

当主服务器进行命令传播时，不仅仅会将写命令发送给所有的从服务器，还会将写命令**入队到复制积压缓冲区**里面(这个大小可以调的)。如果复制积压缓冲区**存在**丢失的偏移量的数据，那就执行部分重同步，否则执行完整重同步。

服务器运行的 ID(**run ID**) 实际上就是用来比对 ID 是否相同。如果不相同，则说明从服务器断线之前复制的主服务器和当前连接的主服务器是两台服务器，这就会进行完整重同步。

![PSYNC 执行](https://cdn.jsdelivr.net/gh/YangZhiqiang98/ImageBed/20211027064317.png)

### 哨兵模式

主从模式中，一旦主节点由于故障不能提供服务，需要人工将从节点晋升为主节点，同时还要通知应用方更新主节点地址。显然，多数业务场景都不能接受这种故障处理方式。Redis 从 2.8 开始正式提供了 Redis Sentinel（哨兵）架构来解决这个问题。

> **哨兵模式**，由一个或多个Sentinel实例组成的Sentinel系统，它可以监视所有的Redis主节点和从节点，并在被监视的主节点进入下线状态时，**自动将下线主服务器属下的某个从节点升级为新的主节点**。但是呢，一个哨兵进程对Redis节点进行监控，就可能会出现问题（**单点问题**），因此，可以使用多个哨兵来进行监控Redis节点，并且各个哨兵之间还会进行监控。
>
> ![Sentinel哨兵模式](https://cdn.jsdelivr.net/gh/YangZhiqiang98/ImageBed/20211101203000.jpg)

**故障切换的过程是怎样的呢**

> 假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行 failover 过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象称为**主观下线**。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行 failover 操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为**客观下线**。这样对于客户端而言，一切都是透明的。

- 主观下线

  - Sentinel 会以每秒一次的频率向与它创建命令连接的实例(包括主从服务器和其他的 Sentinel)**发送 PING 命令**，通过 PING 命令返回的信息判断实例是否在线
  - 如果一个**主服务器**在 `down-after-milliseconds` 毫秒内连续向 Sentinel 发送**无效回复**，那么当前 Sentinel 就会**主观认为**该主服务器已经下线了。

- 客观下线

  - 当 Sentinel 将一个主服务器判断为主观下线以后，为了确认该主服务器是否真的下线，它会向同样监视该主服务器的 Sentinel **询问**，看它们是否也认为该主服务器是否下线。
  - 如果**足够多**的 Sentinel 认为该主服务器是下线的，那么就判定该主服务为客观下线，并对主服务器执行故障转移操作。

> 目前为止的主从+哨兵架构可以说 Redis 是高可用的，但要清楚的是：Redis 还是会**丢失数据**的

丢失数据有两种情况：

- 异步复制导致的数据丢失

  - **有部分数据还没复制到从服务器，主服务器就宕机了**，此时这些部分数据就丢失了

- 脑裂导致的数据丢失

  - 有时候主服务器脱离了正常网络，跟其他从服务器不能连接。此时哨兵可能就会**认为主服务器下线了**(然后开启选举，将某个从服务器切换成了主服务器)，但是实际上主服务器还运行着。这个时候，集群里就会有两个主服务器(也就是所谓的脑裂)。
  - 虽然某个从服务器被切换成了主服务器，但是可能客户端**还没来得及切换到新的主服务器**，客户端还继续写向旧主服务器写数据。旧的服务器重新连接时，会作为从服务器复制新的主服务器(这意味着旧数据丢失)。

### Cluster 集群模式

> 哨兵模式基于主从模式，实现读写分离，它还可以自动切换，系统可用性更高。但是它每个节点存储的数据是一样的，浪费内存，并且不好在线扩容。因此，Cluster 集群应运而生，它在 Redis3.0 加入的，实现了 Redis 的**分布式存储**。对数据进行分片，也就是说**每台 Redis 节点上存储不同的内容**，来解决在线扩容的问题。并且，它也提供复制和故障转移的功能。

#### Cluster集群节点的通讯

一个 Redis 集群由多个节点组成，**各个节点之间是怎么通信的呢**？通过 **Gossip 协议**！

Redis Cluster 集群通过 Gossip 协议进行通信，节点之前不断交换信息，交换的信息内容包括节点出现故障、新节点加入、主从节点变更信息、slot 信息等等。常用的 Gossip 消息分为 4 种，分别是：`ping、pong、meet、fail`。

> - meet 消息：通知新节点加入。消息发送者通知接收者加入到当前集群，meet消息通信正常完成后，接收节点会加入到集群中并进行周期性的ping、pong消息交换。
> - ping 消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送ping消息，用于检测节点是否在线和交换彼此状态信息。
> - pong 消息：当接收到 ping、meet 消息时，作为响应消息回复给发送方确认消息正常通信。pong 消息内部封装了自身状态数据。节点也可以向集群内广播自身的 pong 消息来通知整个集群对自身状态进行更新。
> - fail 消息：当节点判定集群内另一个节点下线时，会向集群内广播一个 fail 消息，其他节点接收到 fail 消息之后把对应节点更新为下线状态。

#### Hash Slot插槽算法

既然是分布式存储，Cluster 集群使用的分布式算法是**一致性 Hash**嘛？并不是，而是 **Hash Slot 插槽算法**。

**插槽算法**把整个数据库被分为 **16384** 个 slot（槽），每个进入 Redis 的键值对，根据 key 进行散列，分配到这 16384 插槽中的一个。使用的哈希映射也比较简单，用 CRC16 算法计算出一个 16 位的值，再对 16384 取模。数据库中的每个键都属于这 16384 个槽的其中一个，集群中的每个节点都可以处理这16384 个槽。

集群中的每个节点负责一部分的 hash 槽，比如当前集群有 A、B、C 三个节点，每个节点上的哈希槽数 = 16384/3，那么就有：

- 节点 A 负责 0~5460 号哈希槽
- 节点 B 负责 5461~10922 号哈希槽
- 节点 C 负责 10923~16383 号哈希槽

#### 故障转移

Redis 集群实现了高可用，当集群内节点出现故障时，通过**故障转移**，以保证集群正常对外提供服务。

Redis 集群通过 ping/pong 消息，实现故障发现。这个环境包括**主观下线和客观下线**。

**主观下线：** 某个节点认为另一个节点不可用，即下线状态，这个状态并不是最终的故障判定，只能代表一个节点的意见，可能存在误判情况。

![主观下](https://cdn.jsdelivr.net/gh/YangZhiqiang98/ImageBed/20211101203645.jpg)



**客观下线：** 指标记一个节点真正的下线，集群内多个节点都认为该节点不可用，从而达成共识的结果。如果是持有槽的主节点故障，需要为该节点进行故障转移。

- 假如节点 A 标记节点 B 为主观下线，一段时间后，节点 A 通过消息把节点 B 的状态发到其它节点，当节点 C 接受到消息并解析出消息体时，如果发现节点 B 的 pfail 状态时，会触发客观下线流程；
- 当下线为主节点时，此时 Redis Cluster 集群为统计持有槽的主节点投票，看投票数是否达到一半，当下线报告统计数大于一半时，被标记为**客观下线**状态。

流程如下：

![客观下线](https://cdn.jsdelivr.net/gh/YangZhiqiang98/ImageBed/20211101203709.jpg)



**故障恢复**：故障发现后，如果下线节点的是主节点，则需要在它的从节点中选一个替换它，以保证集群的高可用。流程如下：

![](https://cdn.jsdelivr.net/gh/YangZhiqiang98/ImageBed/20211101203731.jpg)

- 资格检查：检查从节点是否具备替换故障主节点的条件。
- 准备选举时间：资格检查通过后，更新触发故障选举时间。
- 发起选举：到了故障选举时间，进行选举。
- 选举投票：只有持有槽的**主节点**才有票，从节点收集到足够的选票（大于一半），触发**替换主节点操作**





### 参考资料

[1] https://mp.weixin.qq.com/s/6nBUoP2cid1Qn8XngDMjJw

[2] https://www.jianshu.com/p/f0e042b95249

[3] https://mp.weixin.qq.com/s/1wqbnpN8aeDBoy9NDh66vg [必读]



