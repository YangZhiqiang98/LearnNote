[参考网址](https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/singleton.html)

## 设计模式的原则
1、**单一职责原则**（SRP）：就一个类而言，应该仅有一个引起它变化的原因。
2、**开闭原则**：模块、类和函数应该对扩展开放，对修改关闭。
3、**里氏替换原则**（LSP）：子类型必须能够替换掉它们的父类型。一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化。只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。由于有了里氏替换原则，才使得开闭原则成为了可能，正是由于中子类型的可替换行才使得使得使用父类类型的模块在无需修改的情况下就可以扩展。
4、**接口隔离原则**：客户端不应该依赖于它所不需要的接口。
5、**依赖倒置原则**：抽象不应该依赖细节，细节应该依赖于抽象。即针对接口编程，不要对实现编程。
6、**迪米特法则**（LOD）：又叫作最少知识原则,如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。其根本思想，是强调了类之间的松耦合。类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。

## 分类
- 创建型模式
 1、简单工厂模式
  2、工厂方法模式
  3、抽象工厂模式
  4、建造者模式
  5、单例模式

- 结构型模式
1、适配器模式
2、桥接模式
3、装饰模式
4、外观模式
5、享元模式
6、代理模式
- 行为型模式
1、命令模式
2、中介者模式
3、观察者模式
4、状态模式
5、策略模式

## 创建型模式

创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中**对象的创建和对象的使用分离**。

### 单例模式

 #### 模式动机
对于系统中的某些类来说，只有一个实例很重要，如一个系统中只有一个计时工具和ID（序号）生成器。

单例模式适用情况包括：系统只需要一个实例对象；客户调用类的单个实例只允许使用一个公共访问点。
#### 定义
顾名思义，用来保证一个对象只能创建一个实例，除此之外，它还提供了对实例的全局访问方法。

单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。

#### 实现

为了确保单例实例的唯一性，所有的**单例构造器都要被声明为私有**的，在通过声明**静态方法实现全局访问获得**该单例实例。

**懒汉式**

```java
public class Singleton {
  private static Singleton instance;
  private Singleton(){}

  public static Singleton getInstance(){
    if(instance == null)
      instance = new Singleton();
    return instance;
  }
}
```
**饿汉式**

```java
public class Singleton {
  private static Singleton instance = new Singleton();
  private Singleton(){}

  public static Singleton getInstance(){
    return instance;
  }
}
```
**双重校验锁**
```java
public class Singleton {
  private volatile static Singleton instance = new Singleton();
  private Singleton(){}

  public  static Singleton getInstance(){
    if(instance == null)
      synchronized (Singleton.class){
        if(instance == null)
          instance = new Singleton();
      }
    return instance;
  }
}
```
注意： **volatile** 修饰是必须的， instance = new Singleton()可以拆解为3步
1、分配内存
2、初始化对象
3、指向分配的地址，若发生重排序
假设A 线程执行了1 和 3，还没有执行2，B线程来判断是否为NULL，B线程 就会直接返回还没初始化的instance，volatile可以避免重排序。


```java
/**
 * 无锁的线程安全单例模式
 */
public class Singleton {
  private static final Singleton instance = new Singleton();
  private Singleton(){}
  public static synchronized Singleton getInstance(){
    return instance;
  }
}
```

**静态内部类**：
通过静态内部类的方式实现单例模式是线程安全的，同时静态内部类不会在Singleton类加载时就加载，而是在调用getInstance()方法时才进行加载，达到了懒加载的效果。可能还存在反射攻击或者反序列化攻击

```java
public class Singleton {
    private static class SingletonHolder {
        private static Singleton instance = new Singleton();
    }
    private Singleton() {
        
    }
    public static Singleton getInstance() {
        return SingletonHolder.instance;
    }
}
```
**枚举实现**
```java
public enum Singleton {
    INSTANCE;
    public void doSomething() {
        System.out.println("doSomething");
    }
}
```

### 简单工厂模式

简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。

简单工厂模式适用情况包括：工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心。

简单工厂模式包含如下角色：
- **Factory：工厂角色**
工厂角色负责实现创建所有实例的内部逻辑
- **Product：抽象产品角色**
抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口
- **ConcreteProduct：具体产品角色**
具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。

```java
abstract class Product{
  public abstract void print();
}

class ProductA extends Product{
  @Override
  public void print() {
    System.out.println("A");
  }
}

class ProductB extends Product{
  @Override
  public void print() {
    System.out.println("B");
  }
}

public class Simplle {

  public enum ProductType{
    A,B;
  }
  public static Product createProduct(String type){
    if(type.equals(ProductType.A)){
      return new ProductA();
    }

    if(type.equals(ProductType.B)){
      return new ProductB();
    }
    return null;
  }
}
```

工厂类逻辑非常简单，只负责Product类的实例化，符合单一职责原则；用户只调用Product接口，可以减少耦合，符合依赖倒置原则；但是增加一个新的Product类时，要修改工厂方法，打破了开闭原则。
改进简单工厂模式，使得注册的类在使用时才被实例化，从而保证对扩展开放，同时对修改闭合。
具体的实现方式有以下两种：
- 使用反射机制注册产品类对象和实例化
- 注册产品对象并向每个产品添加newInstance方法，该方法返回与自身类型相同的新实例
#### 使用反射机制进行类注册的简单工厂模式
```java
public class Simplle{
  private Map<String,Class> registeredProducts = new HashMap<>();
  
  public void registerProduct(String productType,Class productClass){
    registeredProducts.put(productType, productClass);
  }
  public Product createProdcut(String type) throws IllegalAccessException, InstantiationException {
    Class productClass = registeredProducts.get(type);
    return (Product) productClass.newInstance();
  }
}
```
反射在某些情况下并不适用，比如，反射机制需要运行时权限，也会降低运行效率。
#### 使用newInstance方法将进行类注册的简单工厂模式
首先在基类添加一个抽象方法（newInstance），在工厂类中保存对象类型与其对应的product对象，通过实例注册一种新的product对象。

```java
abstract class Product{
  abstract public  Product newInstance();
  public abstract void print();
}

class ProductA extends Product{

  @Override
  public ProductA newInstance() {
    return new ProductA();
  }

  @Override
  public void print() {
    System.out.println("A");
  }
}

class ProductB extends Product{

  @Override
  public ProductB newInstance() {
    return new ProductB();
  }

  @Override
  public void print() {
    System.out.println("B");
  }
}

public class Simplle{
  private Map<String,Product> registeredProducts = new HashMap<>();

  public void registerProduct(String productType,Product product){
    registeredProducts.put(productType, product);
  }
  public Product createProdcut(String type) throws IllegalAccessException, InstantiationException {
    return registeredProducts.get(type).newInstance();
  }
}

```
### 工厂方法模式
工厂模式是在静态工厂模式上的改进。工厂类被抽象化，用于实例化特定类产品的代码被转移到实现抽象方法的子类中。这样不需要修改就可以扩展工厂类。

在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。

工厂方法模式包含如下角色：
**Product**：抽象产品
**ConcreteProduct**：具体产品
**Factory**：抽象工厂
**ConcreteFactory**：具体工厂


工厂方法模式适用情况包括：一个类不知道它所需要的对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。

### 抽象工厂模式

抽象工厂模式是工厂方法模式的扩展版本。它不再创建单一类型的对象，而是创建一系列相关联的对象。

工厂方法类中只有一个抽象方法，在不同的具体工厂类中分别实现抽象类产品的实例化，而抽象工厂类中，每个抽象产品都有一个实例化方法。
包含角色：

**AbstractFactory**：抽象工厂
**ConcreteFactory**：具体工厂
**AbstractProduct**：抽象产品
**Product**：具体产品

### 建造者模式

## 结构型模式

### 适配器模式

### 桥接模式

### 装饰模式

### 外观模式

### 享元模式

### 代理模式

## 行为型模式

### 命令模式

### 中介者模式

### 观察者模式

### 状态模式

### 策略模式