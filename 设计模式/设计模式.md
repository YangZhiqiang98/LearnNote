

### 简单工厂模式

简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。

简单工厂模式适用情况包括：工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心。

简单工厂模式包含如下角色：
- **Factory：工厂角色**
工厂角色负责实现创建所有实例的内部逻辑
- **Product：抽象产品角色**
抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口
- **ConcreteProduct：具体产品角色**
具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。

```java
abstract class Product{
  public abstract void print();
}

class ProductA extends Product{
  @Override
  public void print() {
    System.out.println("A");
  }
}

class ProductB extends Product{
  @Override
  public void print() {
    System.out.println("B");
  }
}

public class Simplle {

  public enum ProductType{
    A,B;
  }
  public static Product createProduct(String type){
    if(type.equals(ProductType.A)){
      return new ProductA();
    }

    if(type.equals(ProductType.B)){
      return new ProductB();
    }
    return null;
  }
}
```

工厂类逻辑非常简单，只负责Product类的实例化，符合单一职责原则；用户只调用Product接口，可以减少耦合，符合依赖倒置原则；但是增加一个新的Product类时，要修改工厂方法，打破了开闭原则。
改进简单工厂模式，使得注册的类在使用时才被实例化，从而保证对扩展开放，同时对修改闭合。
具体的实现方式有以下两种：
- 使用反射机制注册产品类对象和实例化
- 注册产品对象并向每个产品添加newInstance方法，该方法返回与自身类型相同的新实例
#### 使用反射机制进行类注册的简单工厂模式
```java
public class Simplle{
  private Map<String,Class> registeredProducts = new HashMap<>();
  
  public void registerProduct(String productType,Class productClass){
    registeredProducts.put(productType, productClass);
  }
  public Product createProdcut(String type) throws IllegalAccessException, InstantiationException {
    Class productClass = registeredProducts.get(type);
    return (Product) productClass.newInstance();
  }
}
```
反射在某些情况下并不适用，比如，反射机制需要运行时权限，也会降低运行效率。
#### 使用newInstance方法将进行类注册的简单工厂模式
首先在基类添加一个抽象方法（newInstance），在工厂类中保存对象类型与其对应的product对象，通过实例注册一种新的product对象。

```java
abstract class Product{
  abstract public  Product newInstance();
  public abstract void print();
}

class ProductA extends Product{

  @Override
  public ProductA newInstance() {
    return new ProductA();
  }

  @Override
  public void print() {
    System.out.println("A");
  }
}

class ProductB extends Product{

  @Override
  public ProductB newInstance() {
    return new ProductB();
  }

  @Override
  public void print() {
    System.out.println("B");
  }
}

public class Simplle{
  private Map<String,Product> registeredProducts = new HashMap<>();

  public void registerProduct(String productType,Product product){
    registeredProducts.put(productType, product);
  }
  public Product createProdcut(String type) throws IllegalAccessException, InstantiationException {
    return registeredProducts.get(type).newInstance();
  }
}

```
### 工厂方法模式

工厂模式是在静态工厂模式上的改进。工厂类被抽象化，用于实例化特定类产品的代码被转移到实现抽象方法的子类中。这样不需要修改就可以扩展工厂类。

在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。

工厂方法模式包含如下角色：
**Product**：抽象产品
**ConcreteProduct**：具体产品
**Factory**：抽象工厂
**ConcreteFactory**：具体工厂


工厂方法模式适用情况包括：一个类不知道它所需要的对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。

### 抽象工厂模式

抽象工厂模式是工厂方法模式的扩展版本。它不再创建单一类型的对象，而是创建一系列相关联的对象。

工厂方法类中只有一个抽象方法，在不同的具体工厂类中分别实现抽象类产品的实例化，而抽象工厂类中，每个抽象产品都有一个实例化方法。
包含角色：

**AbstractFactory**：抽象工厂
**ConcreteFactory**：具体工厂
**AbstractProduct**：抽象产品
**Product**：具体产品

