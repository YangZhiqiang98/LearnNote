### 设计模式原则

##### **单一职责原则**（SRP）

就一个类而言，应该 **仅有一个引起它变化的原因**。

##### **开闭原则**

模块、类和函数应该 **对扩展开放，对修改关闭**。

##### **里氏替换原则**（LSP）

**子类型必须能够替换掉它们的父类型**（**派生类型必须完全可替代其基类型**。）。一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化。只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。由于有了里氏替换原则，才使得开闭原则成为了可能，正是由于子类型的可替换行才使得使用父类类型的模块在无需修改的情况下就可以扩展。



##### **接口隔离原则**

客户端不应该依赖于它所不需要的接口。

##### **依赖倒置原则**

高级模块不应该依赖低级模块，两者都应该依赖抽象；抽象不应该依赖细节，细节应该依赖于抽象。即 **针对接口编程，不要对实现编程**。依赖于抽象进而减少高级逻辑和低级模块之间的依赖关系，达到 **解耦** 的目的

##### **迪米特法则**（LOD）：

又叫作最少知识原则,**如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用**。一个软件实体应当尽可能少地与其他实体发生相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。其根本思想，是强调了 **类之间的松耦合**。类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。

### 设计模式的分类

#### 创建型模式

1.单例模式

2.简单工厂模式

3.工厂方法模式

4.抽象工厂模式

5.建造者模式

#### 结构型模式

1.适配器模式

2.桥接模式

3.装饰模式

4.外观模式

5.享元模式

6.代理模式

#### 行为型模式

1.命令模式

2.中介者模式

3.观察者模式

4.状态模式

5.策略模式