### JMM

#### 内存的交互操作

![](https://cdn.jsdelivr.net/gh/YangZhiqiang98/ImageBed/20220211205544.png)

> 1、lock（锁定）：作用于主内存中的变量，它把一个变量标识为一个线程独占的状态；
> 2、unlock（解锁）：作用于主内存中的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
> 3、read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便后面的 load 动作使用
> 4、load（载入）：作用于工作内存中的变量，它把 read 操作从主内存中得到的变量值放入工作内存中的变量副本
> 5、use（使用）：作用于工作内存中的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作
> 6、assign（赋值）：作用于工作内存中的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作
> 7、store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送给主内存中以便随后的 write 操作使用
> 8、write（操作）：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中



#### JMM 的三大特征

JMM 内存模型是围绕并发编程中 **原子性**、**可见性**、**有序性** 三个特征来建立的。

##### 原子性

基本类型数据的访问大都是原子操作，long 和 double 类型的变量是 64 位，但是在 32 位JVM中，32 位的 JVM 会将 64 位数据的读写操作分为 2 次 32 位的读写操作来进行，这就导致了 long、double 类型的变量在 32 位虚拟机中是非原子操作，数据有可能会被破坏，也就意味着多个线程在并发访问的时候是线程非安全的。
实现原子性的方式：

1、AtomicInteger 等原子类

2、synchronized 关键字

##### 可见性

可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。



主要有三种实现可见性的方式：

1、volatile，通过在指令中添加 lock 前缀指令，lock 前缀指令就相当于一个内存屏障，以此实现可见性。
2、synchronized，当线程获取锁时会从主内存中获取共享变量的最新值，释放锁的时候会将共享变量同步到主内存中。
3、final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。



> 什么是This逃逸？
>
> 在构造器构造还未彻底完成前（即实例初始化阶段还未完成），将自身 this 引用向外抛出并被其他线程复制（访问）了该引用，可能会问到该还未被初始化的变量，甚至可能会造成更大严重的问题。

##### 有序性

有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。

volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。

synchronized 关键字同样可以保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。


> 重排序有三种：编译器重排序、指令重排序、内存系统重排序
>
> 内存屏障请看[相关文章]



#### 先行发生原则 happens-before

> happens-before 是 JMM 定义的 2 个操作之间的偏序关系：如果操作 A 线性发生于操作 B，则 A 产生的影响能被操作 B 观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。如果两个操作满足 happens-before 原则，那么不需要进行同步操作，JVM 能够保证操作具有顺序性，此时不能够随意的重排序。否则，无法保证顺序性，就能进行指令的重排序。

1、单一线程原则：在一个线程内，在程序前面的操作先行发生于后面的操作。

2、管程锁定规则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。

3、volatile 变量规则：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。

4、线程启动规则：Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。

5、线程加入规则：Thread 对象的结束先行发生于 join() 方法返回。

6、线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。

7、对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。

8、传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。

#### 相关文章

[1] [Java内存模型_ThinkWon的博客-CSDN博客](https://blog.csdn.net/ThinkWon/article/details/102073578)

[2] [JMM概述_牧竹子-CSDN博客_jmm](https://blog.csdn.net/zjcjava/article/details/78406330)





#### 双亲委派模型	

[呵，十个双亲委派问题，想问倒我？](https://mp.weixin.qq.com/s/6kedGPZP4iTDuK-Wuzym4Q)
