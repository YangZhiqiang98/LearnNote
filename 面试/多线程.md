

#### ThreadLocal

ThreadLocal 解决多线程的并发问题，是 Thread 的局部变量，使用它维护变量，会使该变量的线程提供一个独立的副本，可以独立修改，不会影响其他线程的副本。

##### 原理

1.每个线程内部有一个 Map，类型为 `ThreadLocal.ThreadLocalMap`

2.对于 ThreadLocalMap 中的每一个 Entry 来说，它的 key 是 ThreadLocal，同时这个 key 为一个 **弱引用**，当 ThreadLocal 没有强引用指向它的时候，下次垃圾回收必定将他回收，因为 value 是**强引用**，所以只要 ThreadLocalMap 存在不会被回收，又因为 ThreadLocalMap 是线程的成员变量，所以value 会一直被保存到线程被销毁，这就有内存泄漏的问题。

```java
static class Entry extends WeakReference<ThreadLocal<?>> {
    /** The value associated with this ThreadLocal. */
    Object value;

    Entry(ThreadLocal<?> k, Object v) {
        super(k);
        value = v;
    }
}
```

3.ThreadLocalMap 的 key 为 ThreadLocal 类型，value 为任意对象，注意 key 是一个 ThreadLocal 类型，它是一个对象，而且多个线程内的 ThreadLocal 是 **共享** 的。



![ThreadLocal](https://cdn.jsdelivr.net/gh/YangZhiqiang98/ImageBed/20220212084533.png)

<center>ThreadLocal-1</center>



##### 为什么ThreadLocalMap 中的 key 是软引用？

> 只有被软引用所指向的对象，下次GC时这个对象必定会被回收。

假如 key 为 **强引用**，如果一个线程将 ThreadLocal 置为 null，这样的话，在 ==所有线程== 内就不能 `get()` 获取值，这个 ThreadLocal 就不能再使用，因为你能使用到的引用已经没有指向这个 ThreadLocal 了，然后这个 ThreadLocal 也不会被回收 ，因为 ThreadLocalMap 中的 key 还指向这个 ThreadLocal 对象，此对象也不会被回收，此时就会出现 **内存泄漏**。最后总结出ThreadLocal使用强引用和软引用都会发生内存溢出的问题。



![内存泄漏](https://cdn.jsdelivr.net/gh/YangZhiqiang98/ImageBed/20220212090549.png)

<center>ThreadLocal-2</center>



##### 那么为什么 JDK 的实现者会使用软引用呢？

软引用保证了在这个 ThreadLocal 对象在没有强引用的时候，会被回收掉，这个 value 怎么办呢？JDK 实现者做了这样一个方法，在 ThreadLocal 对象的get，set 和 remove 方法时，会去清除那些 key 为 null 的 Entry，这样能够保持程序尽可能小的出现内存泄露问题（注意 **使用软引用能尽量小的保证出现内存泄漏问题**），所以 JDK 选择使用软引用是最正确的选择，**在使用 ThreadLocal 时，对于用不到的值，要尽量 remove 清除一下**。



##### **ThreadLocal的内存泄露问题？**

在 ThreadLocal 对象没有强引用指向的时候，这个 ThreadLocal 对象对被回收，然而此时 value 并没有被回收就造成了内存泄漏。（如 ThreadLocal-2 图）

##### **为什么ThreadLocal对象最好使用peivate static来修饰？**

所有线程都会使用一个 ThreadLocal 对象作为key，若为类的实例对象（也就是不加 static 的），每一个实例对象的 ThreadLocal 都是不一样的。（如 ThreadLocal-1 图）

#####  在 ThreadLocal 每次 get 和 set 的时候都会清理掉 key 为 null 的 Entry，为什么还需要每次在不使用 ThreadLocal 的时候，手动调用 remove 方法？

  因为有的线程会 24 小时不间断的执行，不会被垃圾回收器所回收，所以这样就会造成内存泄漏的问题，再者有的线程不调用 get、set 方法也就不会清除 key 为 null 的 Entry，所以还是需要在不使用的时候，手动调用 remove 方法，所以，对于这个问题可以总结一下亮点：

 **一：不知道线程什么时候被收回（如果是线程池里面使用了 ThreadLocal 的话，不 remove 就会有问题了）**

 **二：线程执行 get 和 set 方法的时间不确定， ThreadLocal 每次 get 和 set 的时候都会清理掉 key 为 null 的 Entry，但是你不知道 get 和 set 方法什么时候会执行**。



##### 内存泄漏总结：

 **key 使用软引用解决了 ThreadLocal 对象本身的内存泄漏问题，使用 remove 方法解决了 Entry 的 value 的内存泄漏问题**。

##### 相关文章

[1] [ThreadLocal原理 - 废物大师兄 - 博客园 (cnblogs.com)](https://www.cnblogs.com/cjsblog/p/9773079.html)

[2] [深入理解ThreadLocal的原理及内存泄漏问题_goodluckwj的博客-CSDN博客](https://blog.csdn.net/qq_35634181/article/details/103996977)

---



#### CAS

CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。

CAS算法涉及到三个操作数：

- 需要读写的内存值 V。
- 进行比较的值 A。
- 要写入的新值 B。

当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。



CAS虽然很高效，但是它也存在三大问题：

1. **ABA问题**：CAS 需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是 A，后来变成了 B，然后又变成了 A，那么 CAS 进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA 问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。
   - JDK 从 1.5 开始提供了 `AtomicStampedReference` 类来解决 ABA 问题，具体操作封装在 compareAndSet() 中。compareAndSet() 首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。
2. **循环时间长开销大**。CAS 操作如果长时间不成功，会导致其一直自旋，给 CPU 带来非常大的开销。
3. 只能保证一个共享变量的原子操作：对一个共享变量执行操作时，CAS 能够保证原子操作，但是对多个共享变量操作时，CAS 是无法保证操作的原子性的。
   - Java 从 1.5 开始 JDK 提供了 `AtomicReference` 类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行 CAS 操作。

##### 相关文章

[1] [不可不说的Java“锁”事 - 美团技术团队 (meituan.com)](https://tech.meituan.com/2018/11/15/java-lock.html)



---



#### Java 主流锁

![Java 主流锁](https://cdn.jsdelivr.net/gh/YangZhiqiang98/ImageBed/20220212222835.png)

偏向锁通过对比 Mark Word 解决加锁问题，避免执行 CAS 操作。而轻量级锁是通过用 CAS 操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。

##### 相关文章

[1] [不可不说的Java“锁”事 - 美团技术团队 (meituan.com)](https://tech.meituan.com/2018/11/15/java-lock.html)





#### sleep()，wait()，join()，yield() 区别

　　sleep() 方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入 **阻塞** 状态，该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让 **低优先级** 的线程得到执行机会。但是 sleep() 方法不会释放“锁标志”（不释放锁），也就是说如果有 synchronized 同步块，其他线程仍然不能访问共享数据。sleep 是 Thread 类的静态本地方法。

​	wait() 方法需要和 notify() 及 notifyAll() 两个方法一起介绍，这三个方法用于协调多个线程对共享数据的存取，所以必须在 synchronized 语句块内使用，也就是说，调用 wait()，notify() 和 notifyAll() 的任务在调用这些方法前必须拥有对象的锁。注意，它们都是 Object 类的方法，而不是 Thread 类的方法。

​	wait() 方法与 sleep() 方法的不同之处在于，wait() 方法会释放对象的“锁标志”。当调用某一对象的 wait() 方法后，会使当前线程暂停执行，并将当前线程放入对象等待池中，直到调用了 notify() 方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的拥有权。当调用了某个对象的 notifyAll() 方法，会将对象等待池中的所有线程都移动到该对象的锁标志等待池。

​	除了使用 notify() 和 notifyAll() 方法，还可以使用带毫秒参数的 wait(long timeout) 方法，效果是在延迟 timeout 毫秒后，被暂停的线程将被恢复到锁标志等待池。
​	此外，wait()，notify() 及 notifyAll() 只能在 synchronized 语句中使用。
​	yield() 方法和 sleep() 方法类似，也不会释放“锁标志”，区别在于， yield() 方法只是使当前线程重新回到 **可执行** 状态，所以执行 yield() 的线程有可能在进入到可执行状态后马上又被执行，另外 yield() 方法只能使 **同优先级或者高优先级** 的线程得到执行机会，这也和 sleep() 方法不同。


​	join() 方法会使当前线程等待调用 join() 方法的线程结束后才能继续执行，例如在线程B中调用线程 A 的 join()，那么线程 B 会进入阻塞队列，直到线程 A 结束或中断线程。

---



#### 线程池

##### 使用线程池有什么好处

- **「线程重用，降低资源消耗」**：线程池通常会维护一些线程（数量为 `corePoolSize`），这些线程被重复使用来执行不同的任务，任务完成后不会销毁。在待处理任务量很大的时候，通过对线程资源的复用，避免了线程的频繁创建与销毁，从而降低了系统资源消耗。
- **「控制线程池的并发数，提高响应速度」**：由于线程池维护了一批 `alive` 状态的线程，当任务到达时，不需要再创建线程，而是直接由这些线程去执行任务，从而减少了任务的等待时间。
- **「提高线程的可管理性」**：使用线程池可以对线程进行统一的分配，调优和监控。
- **「储存需要执行的任务」**：当任务提交过多时，可以将任务储存起来，等待线程处理。



##### ThreadPoolExecutor参数含义

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
        
    }
```



1. corePoolSize：线程池核心线程数量，核心线程不会被回收，即使没有任务执行，也会保持空闲状态，设置 allowCoreThreadTimeOut 参数为 true 才会进行回收。如果线程池中的线程少于此数目，则在执行任务时创建。
2. maximumPoolSize：线程池最大线程数，表示在线程池中最多能创建多少个线程。**当线程数量达到 corePoolSize，且 workQueue 队列塞满任务了之后，继续创建线程**，当线程池中的线程数量到达这个数字时，新来的任务会执行拒绝策略。
3. keepAliveTime：表示线程没有任务执行时最多能保持多少时间会被回收，注意，这个参数控制的是超过 corePoolSize 之后的“临时线程”的存活时间。
4. unit：参数 keepAliveTime 的时间单位。
5. workQueue：工作队列，存放提交的等待任务，其中有队列大小的限制。
6. threadFactory：创建线程的工厂类，通常我们会自定义一个threadFactory设置线程的名称，这样我们就可以知道线程是由哪个工厂类创建的，可以快速定位排查问题。
7. handler：如果线程池已满，新的任务进来时的拒绝策略。



##### 线程池线程创建的流程是怎样的

![线程创建流程](https://cdn.jsdelivr.net/gh/YangZhiqiang98/ImageBed/20220214065250.webp)

1. 如果当前运行的线程少于 corePoolSize (核心线程数)，则创建新线程来执行任务（执行这一步骤需要获取全局锁）。
2. 如果运行的线程等于或多于 corePoolSize，则将任务加入 BlockingQueue(阻塞队列/任务队列)。
3. 如果无法将任务加入 BlockingQueue（队列已满），则在非 corePool 中创建新的线程来处理任务（执行这一步骤也需要获取全局锁）。
4. 如果创建新线程将使得当前运行的线程超出 maximumPoolSize 限制，任务将被拒绝，并执行线程饱和策略，如： RejectedExecutionHandler.rejectedExecution() 方法。



##### 工作列队有哪几种实现

在`ThreadPoolExecutor`线程池的API文档中，一共推荐了三种等待队列，它们是：`SynchronousQueue`、`LinkedBlockingQueue`和`ArrayBlockingQueue`；

1. **「SynchronousQueue」**：同步队列。这是一个内部没有任何容量的阻塞队列，任何一次插入操作的元素都要等待相对的删除/读取操作，否则进行插入操作的线程就要一直等待，反之亦然。
2. **「LinkedBlockingQueue」**：基于链表结构实现的有界阻塞队列**，在未指明容量时，容量默认为 Integer.MAX_VALUE**。使用无界队列后，当核心线程都繁忙时，后续任务可以无限加入队列，因此线程池中线程数不会超过核心线程数。这种队列可以提高线程池吞吐量，但代价是牺牲内存空间，甚至会导致内存溢出。
3. **「ArrayBlockingQueue」**：基于数组实现的有界阻塞队列。在线程池初始化时，指定队列的容量，后续无法再调整。这种有界队列有利于防止资源耗尽，但可能更难调整和控制。

另外，Java还提供了另外4种队列：

1. **「PriorityBlockingQueue」**：支持优先级排序的无界阻塞队列。存放在 `PriorityBlockingQueue` 中的元素必须实现 `Comparable` 接口，这样才能通过实现 `compareTo()` 方法进行排序。优先级最高的元素将始终排在队列的头部；`PriorityBlockingQueue` 不会保证优先级一样的元素的排序，也不保证当前队列中除了优先级最高的元素以外的元素，随时处于正确排序的位置。
2. **「DelayQueue」**：延迟队列。基于二叉堆实现，同时具备：无界队列、阻塞队列、优先队列的特征。`DelayQueue` 延迟队列中存放的对象，必须是实现 `Delayed` 接口的类对象。通过执行时延从队列中提取任务，时间没到任务取不出来。
3. **「LinkedBlockingDeque」**：双端队列。基于链表实现，既可以从尾部插入/取出元素，还可以从头部插入元素/取出元素。
4. **「LinkedTransferQueue」**：由链表结构组成的无界阻塞队列。这个队列比较特别的时，采用一种预占模式，意思就是消费者线程取元素时，如果队列不为空，则直接取走数据，若队列为空，那就生成一个节点（节点元素为 null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时发现有一个元素为 null 的节点，生产者线程就不入队了，直接就将元素填充到该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素。

##### 拒绝策略有哪几种

线程池有一个重要的机制：拒绝策略。当线程池`workQueue`已满且无法再创建新线程池时，就要拒绝后续任务了。拒绝策略需要实现`RejectedExecutionHandler`接口，不过`Executors`框架已经为我们实现了4种拒绝策略：

1. **「AbortPolicy」**（默认）：丢弃任务并抛出`RejectedExecutionException`异常。
2. **「CallerRunsPolicy」**：由调用线程处理该任务。(例如io操作，线程消费速度没有NIO快，可能导致阻塞队列一直增加，此时可以使用这个模式)。
3. **「DiscardPolicy」**：直接丢弃任务，不抛出任何异常。（可以配合这种模式进行自定义的处理方式）。
4. **「DiscardOldestPolicy」**：丢弃队列最早的未处理任务，然后重新尝试执行任务。

##### 线程池状态

线程池有 5 种状态



![](https://cdn.jsdelivr.net/gh/YangZhiqiang98/ImageBed/20220214072426.png)

```java
volatile int runState;
// runState is stored in the high-order bits
private static final int RUNNING    = -1 << COUNT_BITS;
private static final int SHUTDOWN   =  0 << COUNT_BITS;
private static final int STOP       =  1 << COUNT_BITS;
private static final int TIDYING    =  2 << COUNT_BITS;
private static final int TERMINATED =  3 << COUNT_BITS;
```

`runState`表示当前线程池的状态，它是一个 `volatile` 变量用来保证线程之间的可见性。

下面的几个`static final`变量表示`runState`可能的几个取值，有以下几个状态：

- **「RUNNING」**：当创建线程池后，初始时，线程池处于 `RUNNING` 状态；
- **「SHUTDOWN」**：如果调用了 `shutdown()` 方法，则线程池处于 `SHUTDOWN` 状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；
- **「STOP」**：如果调用了 `shutdownNow()` 方法，则线程池处于 `STOP` 状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；
- **「TIDYING」**：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。因为terminated()在ThreadPoolExecutor类中是空的，所以用户想在线程池变为TIDYING时进行相应的处理；可以通过重载terminated()函数来实现。
- **「TERMINATED」**：线程池的终止状态，当 terminated 方法执行完毕后，线程池将会处于该状态之下；。



**Executors封装线程池**

Java 通过 Executors 工厂类提供四种线程池，分别为：

**newCachedThreadPool** ：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，否则新建线程。（线程最大并发数不可控制）
**newFixedThreadPool**：创建一个固定大小的线程池，可控制线程最大并发数，超出的线程会在队列中等待。
**newScheduledThreadPool** ： 创建一个定时线程池，支持定时及周期性任务执行。
**newSingleThreadExecutor** ：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。





newCachedThreadPool

```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>(),
                                  threadFactory);
}
```

newScheduledThreadPool

```java
public ScheduledThreadPoolExecutor(int corePoolSize) {
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
          new DelayedWorkQueue());
}

public ScheduledThreadPoolExecutor(int corePoolSize,
                                   ThreadFactory threadFactory) {
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
          new DelayedWorkQueue(), threadFactory);
}
```



newFixedThreadPool

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>());
}

 public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>(),
                                      threadFactory);
    }
```



newSingleThreadExecutor

```java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}

public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>(),
                                threadFactory));
}
```

##### 相关文章

[1] [面试官：详细说一下Java线程池，从设计思想到源码解读！](https://mp.weixin.qq.com/s/pePZRcQVA5SNp00jUw2BWw)

[2] [Java线程池面试要点](https://mp.weixin.qq.com/s/Rr9UrsCGSVlXhhGf-xO7Og)【推荐】

[3] [线程池都有哪些状态 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/107650495)

[4] [线程池的五种状态 - 莫等、闲 - 博客园 (cnblogs.com)](https://www.cnblogs.com/jxxblogs/p/11751944.html)

[5] [Executors类创建四种常见线程池_ThinkWon的博客-CSDN博客_executors四种线程池](https://blog.csdn.net/ThinkWon/article/details/102541990)

---

