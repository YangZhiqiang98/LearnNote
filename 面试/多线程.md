#### ThreadLocal

ThreadLocal 解决多线程的并发问题，是 Thread 的局部变量，使用它维护变量，会使该变量的线程提供一个独立的副本，可以独立修改，不会影响其他线程的副本。

##### 原理

1.每个线程内部有一个 Map，类型为 `ThreadLocal.ThreadLocalMap`

2.对于 ThreadLocalMap 中的每一个 Entry 来说，它的 key 是 ThreadLocal，同时这个 key 为一个 **弱引用**，当 ThreadLocal 没有强引用指向它的时候，下次垃圾回收必定将他回收，因为 value 是**强引用**，所以只要 ThreadLocalMap 存在不会被回收，又因为 ThreadLocalMap 是线程的成员变量，所以value 会一直被保存到线程被销毁，这就有内存泄漏的问题。

```java
static class Entry extends WeakReference<ThreadLocal<?>> {
    /** The value associated with this ThreadLocal. */
    Object value;

    Entry(ThreadLocal<?> k, Object v) {
        super(k);
        value = v;
    }
}
```

3.ThreadLocalMap 的 key 为 ThreadLocal 类型，value 为任意对象，注意 key 是一个 ThreadLocal 类型，它是一个对象，而且多个线程内的 ThreadLocal 是 **共享** 的。



![ThreadLocal](https://cdn.jsdelivr.net/gh/YangZhiqiang98/ImageBed/20220212084533.png)

<center>ThreadLocal-1</center>



##### 为什么ThreadLocalMap 中的 key 是软引用？

> 只有被软引用所指向的对象，下次GC时这个对象必定会被回收。

假如 key 为 **强引用**，如果一个线程将 ThreadLocal 置为 null，这样的话，在 ==所有线程== 内就不能 `get()` 获取值，这个 ThreadLocal 就不能再使用，因为你能使用到的引用已经没有指向这个 ThreadLocal 了，然后这个 ThreadLocal 也不会被回收 ，因为 ThreadLocalMap 中的 key 还指向这个 ThreadLocal 对象，此对象也不会被回收，此时就会出现 **内存泄漏**。最后总结出ThreadLocal使用强引用和软引用都会发生内存溢出的问题。



![内存泄漏](https://cdn.jsdelivr.net/gh/YangZhiqiang98/ImageBed/20220212090549.png)

<center>ThreadLocal-2</center>



##### 那么为什么 JDK 的实现者会使用软引用呢？

软引用保证了在这个 ThreadLocal 对象在没有强引用的时候，会被回收掉，这个 value 怎么办呢？JDK 实现者做了这样一个方法，在 ThreadLocal 对象的get，set 和 remove 方法时，会去清除那些 key 为 null 的 Entry，这样能够保持程序尽可能小的出现内存泄露问题（注意 **使用软引用能尽量小的保证出现内存泄漏问题**），所以 JDK 选择使用软引用是最正确的选择，**在使用 ThreadLocal 时，对于用不到的值，要尽量 remove 清除一下**。



##### **ThreadLocal的内存泄露问题？**

在 ThreadLocal 对象没有强引用指向的时候，这个 ThreadLocal 对象对被回收，然而此时 value 并没有被回收就造成了内存泄漏。（如 ThreadLocal-2 图）

##### **为什么ThreadLocal对象最好使用peivate static来修饰？**

所有线程都会使用一个 ThreadLocal 对象作为key，若为类的实例对象（也就是不加 static 的），每一个实例对象的 ThreadLocal 都是不一样的。（如 ThreadLocal-1 图）

#####  在 ThreadLocal 每次 get 和 set 的时候都会清理掉 key 为 null 的 Entry，为什么还需要每次在不使用 ThreadLocal 的时候，手动调用 remove 方法？

  因为有的线程会 24 小时不间断的执行，不会被垃圾回收器所回收，所以这样就会造成内存泄漏的问题，再者有的线程不调用 get、set 方法也就不会清除 key 为 null 的 Entry，所以还是需要在不使用的时候，手动调用 remove 方法，所以，对于这个问题可以总结一下亮点：

 **一：不知道线程什么时候被收回（如果是线程池里面使用了 ThreadLocal 的话，不 remove 就会有问题了）**

 **二：线程执行 get 和 set 方法的时间不确定， ThreadLocal 每次 get 和 set 的时候都会清理掉 key 为 null 的 Entry，但是你不知道 get 和 set 方法什么时候会执行**。



##### 内存泄漏总结：

 **key 使用软引用解决了 ThreadLocal 对象本身的内存泄漏问题，使用 remove 方法解决了 Entry 的 value 的内存泄漏问题**。

##### 相关文章

[1] [ThreadLocal原理 - 废物大师兄 - 博客园 (cnblogs.com)](https://www.cnblogs.com/cjsblog/p/9773079.html)

[2] [深入理解ThreadLocal的原理及内存泄漏问题_goodluckwj的博客-CSDN博客](https://blog.csdn.net/qq_35634181/article/details/103996977)



#### CAS

CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。

CAS算法涉及到三个操作数：

- 需要读写的内存值 V。
- 进行比较的值 A。
- 要写入的新值 B。

当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。



CAS虽然很高效，但是它也存在三大问题：

1. **ABA问题**：CAS 需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是 A，后来变成了 B，然后又变成了 A，那么 CAS 进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA 问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。
   - JDK 从 1.5 开始提供了 `AtomicStampedReference` 类来解决 ABA 问题，具体操作封装在 compareAndSet() 中。compareAndSet() 首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。
2. **循环时间长开销大**。CAS 操作如果长时间不成功，会导致其一直自旋，给 CPU 带来非常大的开销。
3. 只能保证一个共享变量的原子操作：对一个共享变量执行操作时，CAS 能够保证原子操作，但是对多个共享变量操作时，CAS 是无法保证操作的原子性的。
   - Java 从 1.5 开始 JDK 提供了 `AtomicReference` 类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行 CAS 操作。

##### 相关文章

[1] [不可不说的Java“锁”事 - 美团技术团队 (meituan.com)](https://tech.meituan.com/2018/11/15/java-lock.html)

#### Java 主流锁

![Java 主流锁](https://cdn.jsdelivr.net/gh/YangZhiqiang98/ImageBed/20220212222835.png)

偏向锁通过对比 Mark Word 解决加锁问题，避免执行 CAS 操作。而轻量级锁是通过用 CAS 操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。

##### 相关文章

[1] [不可不说的Java“锁”事 - 美团技术团队 (meituan.com)](https://tech.meituan.com/2018/11/15/java-lock.html)
